# 数学:

## 数论：

### 素数筛选：

```c++
//素数筛选法打表
void Prim () {
    int i,j;
    len = 0;
    memset(f, 0, sizeof (f));
    f[0] = f[1] = 1;
    for (i = 2; i * i < maxn; ++i) {
       if (!f[i]) {
           for (j = 2 * i; j < maxn; j = j + i) {
               f[j] = 1;
           }
       }
    }
    for (i = 2; i < maxn; ++i) {
        if (!f[i]) p[len++] = i;
    }
}
```

###  反素数求解+反素数打表

**问题描述:**
对于任何正整数`x`,起约数的个数记做`g(x)`.例如`g(1)=1`,`g(6)=4`.
如果某个正整数`x`满足:对于任意`i(0<i<x)`,都有`g(i)<g(x)`,则称`x`为反素数.
现在给一个**N**,求出不超过**N**的最大的反素数.
比如:输入**1000 **输出 **840**
思维过程:
求`[1..N]`中约数在大的反素数**-->**求约数最多的数
如果求约数的个数 **756=2^2*3^3*7^1**
`(2+1)*(3+1)*(1+1)=24`
基于上述结论,给出算法:按照质因数大小递增顺序搜索每一个质因子,枚举每一个质因子
为了剪枝:
性质一:一个反素数的质因子必然是从`2`开始连续的质数.
因为最多只需要`10`个素数构造:2,3,5,7,11,13,17,19,23,29
性质二:**p=2^t1*3^t2*5^t3*7^t4.....必然t1>=t2>=t3>=....**

#### 反素数求解函数：

```c++
#include <cstdio>
#include <cstring>
#define ll long long
using namespace std;
 
const int inf = 999999999;
const int prime[16]= {1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
int n;
ll bnum, bsum;
//当前枚举到的数；枚举到的第K大的质因子；该数的约数个数；质因子个数上限。
void getantiprime (ll num, ll k, ll sum, ll limit) {
    //如果约数个数更多，将最优解更新为当前数。
    if (bsum < sum) {
        bsum = sum;
        bnum = num;
    }
    //如果约数个数相同，将最优解更新为较小的数。
    if (bsum == sum && bnum > num) bnum = num;
    if (k > 10) return ;
    ll tmp = num;
     //开始枚举每个质因子的个数。
    for (int i = 1; i <= limit; ++i) {
        if (tmp * prime[k] > n) break;
        tmp = tmp * prime[k];
        getantiprime(tmp, k + 1, sum * (i + 1), i);
    }
}

int main() {
    int t;
    scanf ("%d", &t);
    while (t--) {
        bsum = -inf; bnum = inf;
        scanf("%d", &n);
        getantiprime (1, 1, 1, 50);
        printf("%lld\n", bnum);
    }
    return 0;
}

```

#### 反素数打表函数：

```c++
#include<iostream>
#include<cstring>
#include <cstdio>
#define maxn 600000
using namespace std;
  
int dp[600001];
int main() {
    int i,j;
    freopen("out.txt", "w", stdout);
    memset (dp, 0, sizeof (dp));
    for (i = 1; i <= maxn; i++) {
        for(j = 1; i * j <= maxn; j++) {
                dp[i*j]++;
        }
    }
    int max = 0;
    for (i = 2; i <= maxn; i++) {
        if(dp[i] > max) {
            max = dp[i];
            cout << i << ",";
        }
    }
    cout << endl << endl;
    max = 0;
    for(i = 2; i <= maxn; i++) {
        if(dp[i] > max) {
            max = dp[i];
            cout << dp[i] << ",";
        }
    }
    return 0;
}

int antip[] = {1,2,4,6,12,24,36,48,60,120,180,240,360,720,
840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,
45360,50400,55440,83160,110880,166320,221760,277200,
332640,498960,554400};
int pnum[] = {1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,
60,64,72,80,84,90,96,100,108,120,128,144,160,168,180,192,200,
216};

```



### **欧拉函数：**

#### 欧拉函数:

**定义：**用于计算 p(n)，比n小的所有与n互质的数。

**计算公式：**p(n)=n*(1-1/p1)*(1-1/p2)....*(1-1/pk)【p1,p2,pk都是n的素因子】

**另：**若n=p1^q1*p2^q2*.....*pk^qk

则，p(n)=(p1-1)*p1^(q1-1)*(p1-1)*p2^(q2-1)......*(pk-1)*pk^(qk-1)

**性质：**若m,n互质，φ(mn)=φ(m)φ(n)。当n为奇数时，φ(2n)=φ(n)

#### 欧拉定理：

a,m互质，a^φ(m)≡1(mod m)

例：2,3互质，那么，2^2%3=1

**推论：**对于互质的数a、n，满足a^(φ(n)+1) ≡ a (mod n)

 **欧拉公式的延伸：**一个数的所有质因子之和是euler(n)*n/2。

#### 费马小定理：

假如p是质数，且(a,p)=1，那么 a^(p-1) ≡1（mod p） 假如p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1

#### 费马大定理：

当整数n > 2时，关于x, y, z的不定方程 x^n + y^n = z^n. 无正整数解

#### 威尔逊定理：

当仅当p是素数：( p -1 )! ≡ -1 ( mod p )

```
欧拉函数:
定义：用于计算 p(n)，小于等于n的所有与n互质的数。
计算公式：p(n)=n*(1-1/p1)*(1-1/p2)....*(1-1/pk)【p1,p2,pk都是n的素因子】
另：若n=p1^q1*p2^q2*.....*pk^qk
则，p(n)=(p1-1)*p1^(q1-1)*(p1-1)*p2^(q2-1)......*(pk-1)*pk^(qk-1)
性质：若m,n互质，φ(mn)=φ(m)φ(n)。当n为奇数时，φ(2n)=φ(n)
```

#### 欧拉函数模板：

```
int euler(int n)//返回euler(n)
{
     int i;
     int res = n,a = n;
     for(i = 2;i*i <= a; ++i)
     {
         if(a%i == 0)
         {
             res -= res/i; //p(n) = (p - p/p1)(1 - 1/p2)......
             while(a%i == 0) a/=i;
         }
     }
     if(a > 1) res -= res/a;//存在大于sqrt(a)的质因子
     return res;
}
```

#### 欧拉函数打表：

```
void SE()//select euler//类似于素数筛选法
{
    int i,j;
    euler[1] = 1;
    for(i = 2;i < Max; ++i)  euler[i]=i;
    for(i = 2;i < Max; ++i)
    {
         if(euler[i] == i)//这里出现的肯定是素数
         {
           for(j = i; j < Max; j += i)//然后更新含有它的数
           {
              euler[j] = euler[j]/i*(i - 1);
           }
        }
    }
     //for (int i = 1; i <= 20; ++i) printf("%d ",euler[i]);
}
```

### **扩展欧几里得：**

```
同余：这里主要运用了（2）
同余有三种说法都是等价的,分别为:
　　(1) a和b是模d同余的. a=b(mod d)这里的=是三道杠的。
　　(2) 存在某个整数n,使得a=b+nd .
　　(3) d整除a-b.
```

```
LL Pow(int a,int k)
{
    LL sum = 1;
    for (int i = 1; i <= k; ++i)
    sum *= a;
    return sum;
}
LL exp_gcd(LL a,LL b,LL &x,LL &y)
{
    if (b == 0)
    {
        x = 1; y  =0;
        return a;
    }
    else
    {
        LL d = exp_gcd(b,a%b,x,y);
        LL tmp = x;
        x = y; y = (tmp - (a/b)*y);
        return d;
    }
}
if (p%d != 0)
        {
            printf("FOREVER\n");
        }
        else
        {
            /*
            这里自己开始没理解好，我们求出来的x,y是a*x +　b*y = gcd(a,b)的解，
            而我们要的则是a*x + b*y = p的解，所以要转化一下
            */
            p /= d;
            b /= d;
            a /= d;
            x *= p;
            x = (x%b + b)%b;
            printf("%I64d\n",x);
        }
 
```

**必须注意的是：**在利用扩展欧几里得求解时，要求的a,b必须是非负数，这里a是负数了，所以要处理一下，在利用扩展欧几里德求解时将a = -a;置为正数，把负数加大x上面，于是我们求解出的x事最大的负数，只要将其取反就是最小的正整数了。

 ```mathematica
if (p%d == 0) {
     p /= d;
     a /= d;
     b /= d;
     x*=p;
     x = (x%b + b)%b;
     while (x >= 0) x -= b;//求出最大分数
     x = -x;
     if (ans > x) ans = x;
 }
 ```

### **确定三角形内点的个数：**

```
struct node
{
    double x,y;
}Nve[N],Mve[M];
int Right[N][N],s[N][N];
double save[N][N],angle[M];
int n,m;
//寻找第一个大于等于val的坐标
int bsearch(double val)
{
    int l = 0,r = m - 1;
    int mid = 0,ans = -1;
    while (l <= r)
    {
        mid = (l + r)/2;
        if (angle[mid] > val) r = mid - 1;
        else
        {
            l = mid + 1;
            ans = mid;
        }
    }
    return ans;
}
void init()
{
    int i,j;
    int pos1,pos2;
    //求出任意两点的角度(-pi,pi]
    for (i = 0; i < n; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            if (i == j) continue;
            save[i][j] = atan2((Nve[j].y - Nve[i].y), (Nve[j].x - Nve[i].x));
        }
    }

    for (i = 0; i < n; ++i)
    {
        for (j = 0; j < m; ++j)//枚举i点以i点为中心按极角对m个点排序
        {
            angle[j] = atan2((Mve[j].y - Nve[i].y), (Mve[j].x - Nve[i].x));
        }
        sort(angle,angle + m);
        for (j = 0; j < n; ++j)
        {
            if (i == j) continue;
            double ang = save[i][j];
            pos1 = bsearch(ang);//寻找i->j右边的第一个点也表示1-pos1的个数
            s[i][j] = pos1;
            if (ang >= 0)
            {
                ang -= pi;
                pos2 = bsearch(ang);
                Right[i][j] = pos1 - pos2;
            }
            else
            {
                ang += pi;
                pos2 = bsearch(ang);
                Right[i][j] = m - (pos2 - pos1);
            }
        }
    }
}
int getS(int i,int k,int j)//求i,k,j这个角里面的点的个数
{
    int ang1 = save[k][i];
    int ang2 = save[k][j];
    if (ang1 > ang2)
    {
        if (ang1 - ang2 < pi) return (s[k][i] - s[k][j]);
        else  return (m - (s[k][i] - s[k][j]));
    }
    else
    {
        if (ang2 - ang1 < pi) return s[k][j] - s[k][i];
        else return (m - (s[k][j] - s[k][i]));
    }
}
int main()
{
    //freopen("din.txt","r",stdin);
    int i,j,h;
    int cas = 1;
   while (~scanf("%d%d",&n,&m))
   {
       for (i = 0; i < n; ++i) scanf("%lf%lf",&Nve[i].x,&Nve[i].y);

       for (i = 0; i < m; ++i) scanf("%lf%lf",&Mve[i].x,&Mve[i].y);

       init();

       int ans = 0;
       for (i = 0; i < n; ++i)
       {
           for (j = i + 1; j < n; ++j)
           {
               for (h = j + 1; h < n; ++h)
               {
                   int tmp = getS(i,j,h) + getS(j,h,i) + getS(h,i,j) + Right[i][j] + Right[j][h] + Right[h][i] - 2*m;
                   //printf(">>%d\n",tmp);
                   if (tmp&1) ans++;
               }
           }
       }
       printf("Case %d: %d\n",cas++,ans);
   }
    return 0;
}
```

---



## 阶乘：

### 斯特林公式

斯特林公式是一条用来取n[阶乘](https://zh.wikipedia.org/wiki/%E9%9A%8E%E4%B9%98)[近似值](https://zh.wikipedia.org/wiki/%E8%BF%91%E4%BC%BC%E5%80%BC)的[数学](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8)[公式](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%8F)。一般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特林公式十分好用，而且，即使在n很小的时候，斯特林公式的取值已经十分准确。

公式为：![n! \approx \sqrt{2\pi n}\, \left(\frac{n}{e}\right)^{n}.](https://wikimedia.org/api/rest_v1/media/math/render/svg/89f2825420a3001dc539f1363784f421dcc6d569)

斯特林公式的编程写法：N！=sqrt（2×pi×N）*（N/e）^N；（pi=3.1415926=acos（-1.0），e=2.718）

斯特林公式的转换：lgN！=(lg(2×pi)+lgN)/2+N*(lgN-lge); //+1即为长度。

**模板：**

```
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int PI = acos(-1.0);

int main () {
    int n;
    while (cin >> n) {
        double ans;
        ans = (0.5 * log (2 * PI * n) + n * (log(n) - 1)) / log(10);
        cout << (ll) ans + 1 << endl;
    }
    return 0;
}
```

---



## 计算几何

### 快速幂取模：

```c++
ll modmul(ll a,ll b, ll mod) {
    ll res = 0;
    ll tmp = a;
    while (b) {
        if (b & 1) res = (res + tmp) % mod;
        tmp = (tmp + tmp) % mod;
        b >>= 1;
    }
    return res;
}
ll modexp(ll a, ll b, ll mod) {
    ll res = 1;
    ll tmp = a;
    while (b) {
        if (b & 1) res = modmul (res, tmp, mod);
        tmp = modmul(tmp, tmp, mod);
        b >>= 1;
    }
    return res;
}
```

### 矩阵快速幂：

```c++
/*数据结构*/
struct Mat{
    ll mat[3][3];
    void init(){
        for (int i = 0; i < 2; ++i){
            for (int j = 0; j < 2; ++j){
                mat[i][j] = ;
            }
        }
        mat[1][1] = 0；
    }
};
Mat operator * (Mat a,Mat b){
    Mat c;
    int i,j,k;
    CL(c.mat,0);
    for (i = 0; i < 2; ++i){
        for (j = 0; j < 2; ++j){
            for (k = 0; k < 2; ++k){
                if (!a.mat[i][k] || !b.mat[k][j]) continue;
                c.mat[i][j] += a.mat[i][k]*b.mat[k][j];
                if (c.mat[i][j] > MOD) c.mat[i][j] %= MOD;
            }
        }
    }
    return c;
}
Mat operator ^ (Mat a,ll k){
    Mat c;
    int i,j;
    //单位矩阵
    for (i = 0; i < 2; ++i){
        for (j = 0; j < 2; ++j){
            c.mat[i][j] = (i == j);
        }
    }
    //求k次幂
    while (k){
        if (k&1) c = c*a;
        k >>= 1;
        a = a*a;
    }
    return c;
}
```



### 高斯消元：

```c++
int a[N][N],X[N];//分别记录增广矩阵和解集
int free_x[N];//记录自由变量
int equ,var;//分别表示方程组的个数和变量的个数

int GCD(int x,int y){
    if (y == 0) return x;
    return GCD(y,x%y);
}
int LCM(int x,int y){
    return x/GCD(x,y)*y;
}
void Debug(void)
{
    int i, j;
    for (i = 0; i < equ; i++)
    {
        for (j = 0; j < var + 1; j++)
        {
            cout << a[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
}
// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)
int Guass(){
    int i,j,k,col;
    CL(X,0); CL(free_x,1);//把解集清空，所有变量都标为自由变量

    for (k = 0,col = 0; k < equ && col < var; ++k, ++col){//枚举行列
        int max_r = k;//找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        for (i = k + 1; i < equ; ++i){
            if (iabs(a[i][col]) > iabs(a[max_r][col])) max_r = i;
        }
        if (max_r != k){//交换
            for (i = k; i < var + 1; ++i) swap(a[k][i],a[max_r][i]);
        }
        if (a[k][col] == 0){//如果对应该列都为0，枚举该行的下一列
            k--; continue;
        }
        for (i = k + 1; i < equ; ++i){//将k后边的col进行初等变换成行阶梯矩阵
            if (a[i][col] != 0){
                int lcm = LCM(a[k][col],a[i][col]);
                int ta = lcm/iabs(a[i][col]); int tb = lcm/iabs(a[k][col]);
                if (a[i][col]*a[k][col] < 0) tb = -tb;
                for (j = col; j < var + 1; ++j){
                    a[i][j] = ta*a[i][j] - tb*a[k][j];
                }
            }
        }
    }
    Debug();
    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0). 即R(A) != R(A')无解
    for (i = k; i < equ; ++i){
        if (a[i][col] != 0) return -1;
    }
   // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
   // 且出现的行数即为自由变元的个数.   即R(A) = R(A') < n
    if (k < var){
         // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.
        int num = 0,freeidx;
        for (i = k - 1; i >= 0; --i){
            num = 0;// 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.
            int tmp = a[i][var];
            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.
            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.
            for (j = 0; j < var; ++j){
                if (a[i][j] != 0 && free_x[j]){
                    num++;
                    freeidx = j;
                }
            }
            if (num > 1) continue; // 无法求解出确定的变元.
          // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.
            tmp = a[i][var];
            for (j = 0; j < var; ++j){
                if (a[i][j] && j != freeidx) tmp -= a[i][j]*X[j];
            }
            X[freeidx] = tmp/a[i][freeidx];
            free_x[freeidx] = 0;
        }
        return var - k;
    }
    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.
    // 计算出Xn-1, Xn-2 ... X0.
    for (i = k - 1; i >= 0; --i){
        int tmp = a[i][var];
        for (j = i + 1; j < var; ++j){
            tmp -= a[i][j]*X[j];
        }
        X[i] = tmp/a[i][i];
    }
    return 0;
}
```

---



###  多边形模板:

#### 点结构:

```c++
struct point
{
    double x,y;
    point(double a = 0,double b = 0): x(a),y(b){}
};
```

#### 浮点数处理:

```c++
int dblcmp(double x)
{
    if(fabs(x) < eps)
        return 0;
    return x > 0 ? 1:-1;
}
```

或者

```c++
或者
int dblcmp(double x)
{
    if (x > eps) return 1;
    else if (x < -eps) return -1;
    else return 0;
}
判断线段是否相交并求交点（规范相交）
double det(double x1, double y1, double x2, double y2)
{    //求叉积
    return x1*y2 - x2*y1;
}
 
double cross(Point a, Point b, Point c) 
{    //向量ab，和向量ac
    return det(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);
}
 
double dotdet(double x1, double y1, double x2, double y2) 
{    //点积
    return x1*x2 + y1*y2;
}
 
double dot(Point a, Point b, Point c)
{
    return dotdet(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);
}
 
int betweenCmp(Point a, Point b, Point c) 
{    //判断a是不是在bc范围内
    return dbcmp(dot(a, b, c));
}
 
bool segcross(Point a, Point b, Point c, Point d)
{
    double s1, s2;
    int d1, d2, d3, d4;
    d1 = dbcmp(s1 = cross(a, b, c));
    d2 = dbcmp(s2 = cross(a, b, d));
    d3 = dbcmp(cross(c, d, a));
    d4 = dbcmp(cross(c, d, b));
    if((d1^d2) == -2 && (d3^d4) == -2) 
    {    //规范相交
        return true;
    }
    //非规范相交
    if((d1 == 0 && betweenCmp(c, a, b) <= 0) ||
       (d2 == 0 && betweenCmp(d, a, b) <= 0) ||
       (d3 == 0 && betweenCmp(a, c, d) <= 0) ||
       (d4 == 0 && betweenCmp(b, c, d) <= 0))
        return true;
    return false;
}
```



#### 叉积求多边形面积：

```c++
double area(point p[],int n)
 { //这里是相对于原点(0, 0)，也可以在多边形上找一个点作为向量的起点
    double s = 0;
    int i;
    p[n].x = p[0].x;
    p[n].y = p[0].y;
    for(i = 0; i < n; ++i)
        s += det(p[i].x, p[i].y, p[i+1].x, p[i+1].y);
    return fabs(s / 2.0);
}
```



#### 三角形公式：

##### 1.海伦公式：

![formula](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3652749987,823871558&fm=58)

公式描述：公式中a，ｂ，ｃ分别为三角形三边长，ｐ为半周长，Ｓ为三角形的面积。

```mathematica
p = (a+b+c)/2;  
S = sqrt(p*(p-a)*(p-b)*(p-c));
```

##### **2:叉积求解：一直三点：**

```mathematica
A(x1,y1),B(x2,y2),C(x3,y3);  
S = fabs(-x2 * y1 + x3*y1+x1*y2-x3*y2-x1*y3+x2*y3) / 2.0;
```

#### 判断多边形是否为凸多边形

输入p[1],p[2] ...p[n]。 令p[0] = p[n] p[n + 1] = p[1];

```c++
bool isconvexpg()
{
    int dir = 0;
    for (int i = 0; i <= n - 1; ++i)
    {
        int temp = dblcmp(cross(p[i],p[i + 1],p[i + 2]));
        if (!dir) dir = temp;
        if (dir*temp < 0) return false;
    }
    return true;
}
```



#### 判断一点是否在多边形内，环顾法：

```c++
double getdis(point a,point b)
{
    double x = a.x - b.x;
    double y = a.y - b.y;
    return sqrt(x*x + y*y);
}
//利用点积求角度
double getangle(point a,point b,point c)
{
    double dj = dotdet(b.x - a.x,b.y - a.y,c.x - a.x,c.y - a.y);
    double dis = getdis(a,b)*getdis(a,c);
    double tmp = dj/dis;
    return acos(tmp);
}
//判断是否在多边形内
bool IsIn()
{
    int i;
    double angle = 0.0;
    for (i = 1; i <= n; ++i)
    {
        if (dblcmp(cross(cir,p[i],p[i + 1])) >= 0)
        angle += getangle(cir,p[i],p[i + 1]);
        else
        angle -= getangle(cir,p[i],p[i + 1]);
    }
    //printf("angle == %lf\n",angle);
    if (dblcmp(angle) == 0) return false;//在外边
    else if (dblcmp(angle - pi) == 0 || dblcmp(angle + pi) == 0)//在边上
    {
        if (dblcmp(r) == 0) return true;
    }
    else if (dblcmp(angle - 2.0*pi) == 0 || dblcmp(angle + 2.0*pi) == 0)//在里面
    {
        return true;
    }
    else //在多边行顶点
    {
        if (dblcmp(r) == 0) return true;
    }
    return false;
}
```



#### 求凸包的graham_scan算法模板：

```c++
//这里起点与终点肯定在凸包上，不知道怎么证明
int graham(point *p,int len)
{
    top = 0;  int i;
    //先排序，lrj黑书上的排序方法
    sort(p,p + len,cmp);
    stack[top++] = p[0];
    stack[top++] = p[1];
    //求右链
    for (i = 2; i < len; ++i)
    {
        while (top > 1 && dblcmp(cross(stack[top - 2],stack[top - 1],p[i])) <= 0) top--;
        stack[top++] = p[i];
    }
    //求左链
    int tmp = top;
    for (i =len - 2; i >= 0; --i)
    {
        while (top > tmp && dblcmp(cross(stack[top - 2],stack[top - 1],p[i]))<= 0) top--;
        stack[top++] = p[i];
    }
    return top - 1;//起点两次进栈 - 1
}
```



#### 利用凸包求最远点距离——旋转卡壳法：

```c++
int rotaing(point *p,int len)
{
    p[len] = p[0];
    int ans = 0,q = 1;
    for (int i = 0; i < len; ++i)
    {
        while (cross(p[i],p[i + 1],p[q + 1]) > cross(p[i],p[i + 1],p[q]))
        q = (q + 1)%len;
        ans = max(ans,max(dis2(p[i],p[q]),dis2(p[i + 1],p[q + 1])));
        //这里之所以计算i+1与q+1的距离是考虑到在凸多边形中存在平行边的问题
    }
    return ans;
}
```

---

## 组合数学：

#### 排列组合：

p(n,m)=n(n-1)(n-2)……(n-m+1)= n!/(n-m)!(规定0!=1).

c(n,m)=p(n,m)/m!=n!/((n-m)!*m!)；c(n,m)=c(n,n-m);

==注意这里的公式c(i,j) = c(i - 1,j  -1) + c(i - 1,j);==

==c(n,0) + c(n,1) + c(n,2) + c(n,3) + ...... + c(n,n) = 2^n==

#### 容斥定理:

#### 母函数模板：

```c++
整数拆分：
void init(int n){
    int i,j,k;
    for (i = 0; i <= n; ++i){
        c1[i] = 1;//乘完后的系数
        c2[i] = 0;//乘的过程中的系数
    }

    for (i = 2; i <= n; ++i){
        //总共有n个括号,从第2个起每一个括号都要和前面那一个括号相乘
    //所以可以忽略第一个括号 
        for (j = 0; j <= n; ++j){//j代表最前面这个大括号的项数 
            for (k = 0; k + j <= n; k += i){//在大括号后面,x都是以i方递增的 
                c2[k + j] += c1[j];//这里就是大括号后面的括号与前面相乘的计算 
            }
        }
        for (j = 0; j <= n; ++j){
            c1[j] = c2[j];
            c2[j] = 0;
        }
    }
}
动态的增加项：
int MAX = 0;
        for (i = 0; i < n; ++i){
            scanf("%d%d",&val[i],&num[i]);
            MAX += (val[i]*num[i]);
        }
        for (i = 0; i <= MAX; ++i){
            c1[i] = c2[i] = 0;
        }
        int len = val[0]*num[0];
        for (i = 0; i <= len; i += val[0]){
            c1[i] = 1;
        }
        for (i = 1; i < n; ++i){
            for (j = 0; j <= len; ++j){
                for (k = 0; k <= val[i]*num[i]; k += val[i]){
                    c2[k + j] += c1[j];
                }
            }
            len += val[i]*num[i];
            for (j = 0; j <= len; ++j){
                c1[j] = c2[j];
                c2[j] = 0;
            }
        }
        int ave = MAX/2;
        for (i = ave; i >= 0; --i){
            if (c1[i]) break;
        }
        int A = i;
        int B = MAX - A;
        printf("%d %d\n",max(A,B),min(A,B));
```

#### Java解大整数问题:

```java
public static BigInteger add(BigInteger a, BigInteger b) {
        return a.add(b);
    }

    public static BigInteger subtract(BigInteger a, BigInteger b) {
        return a.subtract(b);
    }

    public static BigInteger multiply(BigInteger a, BigInteger b) {
        return a.multiply(b);
    }

    public static BigInteger divide(BigInteger a, BigInteger b) {
        return a.divide(b);
    }

    public static BigInteger mod(BigInteger a, BigInteger b) {
        return a.mod(b);
    }
以下是BigDecimal数的加、减、乘、除
    public static BigDecimal add(BigDecimal a, BigDecimal b) {
        return a.add(b);
    }

    public static BigDecimal subtract(BigDecimal a, BigDecimal b) {
        return a.subtract(b);
    }

    public static BigDecimal multiply(BigDecimal a, BigDecimal b) {
        return a.multiply(b);
    }

    public static BigDecimal divide(BigDecimal a, BigDecimal b) {
        return a.divide(b);
    }
最近点对：
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
const int max_s = 100007;
using namespace std;
const int M = 99999999.0;
struct node
{
    double x,y;
}p[max_s];
int a[max_s];
int cmp_x(node a,node b)
{
  return a.x>b.x;
}
int cmp_y(int s,int e)
{
    return p[s].y>p[e].y;
}
double dis(node t1,node t2)
{
    double x=t1.x-t2.x;
    double y=t1.y-t2.y;
    return sqrt(x*x+y*y);
}
double short_s(int l,int r)//分治的思想
{
    int i,j;
    if(l==r) return M;
    else if(l+1==r) return dis(p[l],p[r]);
    int m=(l+r)>>1;
    double Min=min(short_s(l,m),short_s(m+1,r));
    int k=0;
    for(i=l;i<=r;i++)//这里是从L开始的。。
    {
        if(p[i].x>=p[m].x-Min&&p[i].x<=p[m].x+Min)
        a[k++]=i;
    }
    sort(a,a+k,cmp_y);
    for(i=0;i<k-1;i++)
    {
        for(j=i+1;j<k;j++)
        {
            if(p[a[i]].y-p[a[j]].y>=Min)
            break;
            Min=min(Min,dis(p[a[j]],p[a[i]]));
        }
    }
    return Min;
}
int main()
{
    //freopen("d.txt","r",stdin);
    int n,i;
    while(scanf("%d",&n),n)
    {
        for(i=0;i<n;i++)
        scanf("%lf%lf",&p[i].x,&p[i].y);
        sort(p,p+n,cmp_x);//sort的速度要比qsort的快一些貌似。。
        printf("%.2lf\n",short_s(0,n-1)/2);
    }
    return 0;
}
```





# 数据结构：

## 哈希方法：

### 开散列：

#### 挂链：

```c++
void Gua(int tmp){
    int tp = tmp%N;
    if (tp < 0) tp = -tp;
    node *t = &H[pos++];
    t->num = tmp;
    t->next = tagp[tp];
    tagp[tp] = t;
}
int Cha(int tmp){
    int tp = tmp%N;
    if (tp < 0) tp = -tp;
    node *q;
    int count = 0;
    for (q = tagp[tp]; q != NULL; q = q->next){
        if (q->num == tmp) count++;
    }
    return count;
}
```

#### Vector　实现:

```c++
vector<int>hash[N];
void Gua(int tmp){
    int tp = tmp%N;
    if (tp < 0) tp = -tp;
    hash[tp].push_back(tmp);
}
int Cha(int tmp){
    int tp = tmp%N;
    if (tp < 0) tp = -tp;
    int count = 0,k;
    int sz = hash[tp].size();
    for (k = 0; k < sz; ++k){
        if (hash[tp][k] == tmp) count++;
    }
    return count;
}
```

#### 几种经典方法：

##### Unix的ELF哈希函数：

```c++
unsigned int ELFHash(char* str)
{
    unsigned int hash = 0;
    unsigned int x = 0;
 
    while (*str){
        hash = (hash << 4) + (*str++);
        if ((x = hash & 0xF0000000L) != 0){
            hash ^= (x >> 24);
            hash &= ~x;
        }
    }
    return (hash & 0x7FFFFFFF);
}
```

##### BKDRHash 哈希：

```c++
unsigned int BKDRHash(char * str)  
{  
    unsigned int seed = 31;//31 131 1313 13131  
    unsigned int key = 0;  
    while (*str)  
        key = key*seed+ *str++;  
    return key&(0x7fffffff);  
}  
```

### KMP模板：

```c++
void GetNext(char *s)
{
    int len = strlen(s);
    int i,j;
    i = 0; j = -1;//j从0开始，i从1开始
    next[0] = -1;
    for (i = 1; i < len; ++i)
    {
        while (j > -1 && s[j + 1] != s[i])//不相同的话j就跳跃知道相同或者成为-1
        j = next[j];
        if (s[j + 1] == s[i]) ++j;//相同更新j
        next[i] = j;//每一次都要求出next[i]
    }
}

void kmp(char *s1,char *s2)//s1副串 s2主串
{
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    int i,j = -1;
    int ans = 0;
    for (i = 0; i < len2; ++i)
    {
        while (j > -1 && s1[j + 1] != s2[i]) j = next[j];
        if (s1[j + 1] == s2[i]) ++j;
        if (j == len1 - 1)//找到子串，后继续查找
        {
            ans++;
            j = next[j];
        }
    }
    printf("%d\n",ans);
}
```

### 并查集模板：

```c++
for (i = 0; i <= n; ++i)
 f[i] = i;

int find(int x)
{
    if (x != f[x])
    {
        f[x] = find(f[x]);
    }
    return f[x];
}

经常使用的：
void Union(int x,int y)
{
    x = find(x);
    y = find(y);
    if (x != y)
    {
        f[y] = x;
        num[x] += num[y];//根记录子系的个数
    }
}
还有一种写法：
void Union(int root1, int root2)
{
     int x = FindSet(root1), y = FindSet(root2);
     if( x == y ) return ;
     if( rank[x] > rank[y] ) parent[y] = x;
     else{
         parent[x] = y;
         if( rank[x] == rank[y] ) ++rank[y];
     }
}
```



**种类并查集：**

pku 1703 Find them, Catch them

**题意：**

总共存在两个帮派，有两种操作D [a][b] 说明a,b属于不同的帮派，A [a][b] 需要我们来判断他们的关系，属于同一帮派输出，属于不同的帮派，或者不确定。



**思路：**

利用并查集构成的树的长度关系，我们把不同的利用并查集合并，然后维持一个他们到根节点的距离dep我们只要判断他们的距离的差值是否为2的倍数就可判断时代否在同以帮派了。

```c++
void init(){
    int i;
    for (i = 0; i <= n; ++i){
        f[i] = i;
        dep[i] = 0;
    }
}
//find函数里面维护dep
int find(int x){
    if (x != f[x]){
        int tmp = f[x];
        f[x] = find(f[x]);
        dep[x] = (dep[tmp] + dep[x])%2;//更新未压缩的点，保持dep的正确性
    }
    return f[x];
}
void Union(int x,int y){
    int tx = find(x);
    int ty = find(y);
    if (tx != ty){
        f[ty] = tx;
        dep[ty] = (dep[x] + dep[y] + 1)%2;//维护根节点的正确性
    }
}
int main(){
    //freopen("din.txt","r",stdin);
    int i;
    int T,m;
    char op[3];
    int x,y;
    scanf("%d",&T);
    while (T--){
        scanf("%d%d",&n,&m);
        init();
        for (i = 0; i < m; ++i){
            scanf("%s%d%d",op,&x,&y);
            if (op[0] == 'D'){
                Union(x,y);
            }
            else{
                int tx = find(x);
                int ty = find(y);
                if (tx != ty) printf("Not sure yet.\n");
                else{
                    if (iabs(dep[x] - dep[y])%2 == 0) printf("In the same gang.\n");
                    else printf("In different gangs.\n");
                }
            }
        }
    }
    return 0;
}
```



**（pku 食物链 1182）**

![图片1](/home/heng/图片1.png)

![图片2](/home/heng/图片2.png)

```c++
int dep[N],f[N];
int n,k;
int ct;

void init(){
    int i;
    for (i = 0; i <= n; ++i){
        f[i] = i;
        dep[i] = 0;
    }
}
int find(int x){
    if (x != f[x]){
        int tmp = f[x];
        f[x] = find(f[x]);
        dep[x] = (dep[x] + dep[tmp])%3;
    }
    return f[x];
}
void Union(int x,int y,int mk){
    int tx = find(x);
    int ty = find(y);
    if (tx != ty){
        f[tx] = ty;
        dep[tx] = (dep[y] + mk - dep[x])%3;//维护dep数组
    }
    else{
        if ((dep[x] - dep[y] + 3)%3 != mk) ct++;
    }
}
int main(){
  //  freopen("din.txt","r",stdin);
    ct = 0;
    int op,x,y;
    scanf("%d%d",&n,&k);
    init();
    while (k--){
        scanf("%d%d%d",&op,&x,&y);
        if (x > n || y > n || (op == 2 && x == y)){
            ct++;
            continue;
        }
        if (op == 1){
            Union(x,y,0);//同类合并时，间距为0
        }
        else{
            Union(x,y,1);//不是关系时，间距为1
        }
    }
    printf("%d\n",ct);
    return 0;
}
```

---

### 字典树模板:

```c++
struct node
{
    int flag;
    node *next[27];
}*head;

/*动态分配内存*/
node * newnode()
{
    int i;
    node * p = new node;    // c语言用(node * )malloc(sizeof(node), 这里是动态分配内存，时间上可能消耗的多一些
    p->flag = 0;
    for(i = 0; i < 26; i++)
        p->next[i] = NULL;
    return p;
}
 
/*静态分配内存*/
node T[1000000];
int t = 0;
node * newnode()
{
    int i;
    node * p = &T[t++];  
    p->flag = 0;
    for(i = 0; i < 26; i++)
        p->next[i] = NULL;
    return p;
}
```



**注意：**

1：在此之前head一定要先分配，否则无法执行，这里自己老是出错。

2：还有如果处理多组数据的话一定要注意清空T[]数组，否则影响后边的处理。

```c++
void insert(char *s)
{
    int i,k;
    int len = strlen(s);
    node *p = head;
    for (i = 0; i < len; ++i)
    {
        k = s[i] - 'a';
        if (p->next[k] == NULL)
        p->next[k] = newnode();
        p = p->next[k];
    }
    p->flag = 1;
}

bool search(char *s)
{
    int i,k;
    int len = strlen(s);
    node *p = head;
    for (i = 0; i < len; ++i)
    {
        k = s[i] - 'a';
        if (p->next[k]) p = p->next[k];
        else
        return false;
    }
    if (p->flag) return true;
    else return false;
}

void del(node * p) {
    int i;
    if(p)                   //p不为空
    {
        for(i =0; i <26; i++)
            if(p->next[i])
                del(p->next[i]);        //递归删除每一个p->next[]
    }
    free(p);
    p = NULL;        
}
```



### 拓扑排序：

```c++
int topor()
{
    int i,j,k;
    bool flag;
    memset(ind,0,sizeof(ind));
    for (i = 1; i <= n; ++i)
    {
        for (j = 1; j <= n; ++j)
        {
            if (map[i][j])
            ind[j]++;
        }
    }
    flag = false;//判断是否存在多个入度为0的点
    memset(as,0,sizeof(as));
    for (k = 0; k < n; ++k)
    {
        i = 0;
        for (j = 1; j <= n; ++j)
        {
            if (ind[j] == 0)
            {
                if (i == 0)//判断入度为0的点就一个
                 i = j;
                else//出现多个
                flag = true;
            }
        }
        if (i == 0) return 1;//没有入度为0的点
        as[k] = i + 'A' - 1;
        ind[i] = -1;
        for (j = 1; j <= n; ++j)
        {
            if (map[i][j])
            ind[j]--;
        }
    }
    if (!flag) return 0;
    else  return 2;
}
```



### RMQ算法 (ST表)：

```c++
void init_rmqMIN()
{

    for(int i = 1;i <= n; ++i){
        dp1[i][0] = a[i];
    }
    for(int j = 1; pow2[j] <= n; ++j){
        for(int i = 1; (i + pow2[j] - 1) <= n; ++i){
                dp1[i][j] = min(dp1[i][j-1],dp1[i + (1 << (j-1))][j-1]);
        }

    }
}
int rmqMIN(int l,int r){
    int d = log((double)(r - l + 1)) / log(2.0);
    return min(dp1[l][d],dp1[r - pow2[d] + 1][d]);
}
void init_rmqMAX()
{
    for(int i = 1;i <= n; ++i){
        dp2[i][0] = a[i];
    }
    for(int j = 1; pow2[j] <= n; ++j){
        for(int i = 1; (i + pow2[j] - 1) <= n; ++i){
                dp2[i][j] = max(dp2[i][j-1],dp2[i + (1 << (j-1))][j-1]);
        }

    }
}
int rmqMAX(int l,int r){
    int d = log((double)(r - l + 1)) / log(2.0);
    return max(dp2[l][d],dp2[r - pow2[d] + 1][d]);
}
```



### 树状数组：

首先要分清==a[], c[], sum[]== 他们各自所代表的意思；

**a[]**就是输入的数组；

**c[]**就是建立的树状数组；

**c[i] = a[i - 2^k +1] + ...... + a[i];**

**a**有多少个**c**就有多少个，而且**c[i]**肯定包含相应的**a[i]**;

**lowbit(i) = 2^k** 表示i的二进制数表示形式留下左右边的**1**其余为取**0**得到的数

**sum[k] = c[N1] + c[N2] + c[N3].......+ c[Nm]**;

**Ni-1 = Ni - lowbit(i)**;

求和的话，就是有**c[Nm]  c[Nm-1]  c[Nm-2] .... c[N1]**的过程 **Ni - lowbit(i)**的过程是将**Ni**的二进制的最右边的**1**去掉的过程，所以求和的时间复杂度为==O(log(k))==;

而更新也是如果**a[i]**更新了 那么**c[N1] c[N2] ..... C[Nm]**也要更新**N1= i**; 就是从**c[N1] c[N2] ... c[Nm]**的过程 **Ni = Ni-1 + lowbit(i)**;就是在**Ni - 1**的二进制最右边**1**后边填**1**的过程，就是在时间复杂度也是==O(log(n))==级别。

**适用于：**==单点更新==，==区间求和==；

```c++
int lowbit(int x)
{
   //return x^(x&(x - 1));
    return x&(-x);
}
void modify(int pos,int sc)//位置pos更新sc
{
    while (pos <= n)//由C[N1]到C[Nm]的过程
    {
        c[pos] += sc;
        pos += lowbit(pos);
    }
}
int getsum(int pos)
{
    int sum = 0;
    while (pos > 0)//由C[Nm]到C[N1]的过程
    {
        sum += c[pos];
        pos -= lowbit(pos);
    }
    return sum;
}
二位树状数组模板题目：

给出n*n的矩阵，有两种操作，

1 x,y,z  将(x,y)方格的数更新z      2 x1,y1,x2,y2求方格(x1,y1)到(x2,y2)中的总数。

注意求和公式后面要加上多减去的部分。
int lowbit(int x)
{
    return x&(-x);
}

void modify(int x,int y,int sc)
{
    int i,j;
    for (i = x; i <= n; i += lowbit(i))
    {
        for (j = y; j <= n; j += lowbit(j))
        {
            c[i][j] += sc;
        }
    }
}
int getsum(int x,int y)
{
    int i,j;
    int sum = 0;
    for (i = x; i > 0; i -= lowbit(i))
    {
        for (j = y; j > 0; j -= lowbit(j))
        {
            sum += c[i][j];
        }
    }
    return sum;
}
int main()
{
    //freopen("d.txt","r",stdin);
    int op,x1,y1,z,x2,y2;
    memset(c,0,sizeof(c));
    while (scanf("%d",&op))
    {
        if (op == 3) break;
        else if (op == 0) scanf("%d",&n);
        else if (op == 1)
        {
            scanf("%d%d%d",&x1,&y1,&z);
            modify(x1 + 1,y1 + 1,z);
        }
        else
        {
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            printf("%d\n",getsum(x2 + 1,y2 + 1) - getsum(x1,y2 + 1)
                    - getsum(x2 + 1,y1) + getsum(x1,y1));
        }
    }
    return 0;
}
```



### 线段树:

#### 线段树（乘法）

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int n,m;
ll ans,p,num[3000100];
struct Node
{
    int l,r,num;
    ll sum,lazy,mul;
} tr[4000100];
void pushup(int now)
{
    tr[now].sum=(tr[now<<1].sum+tr[now<<1|1].sum)%p;
}
void buildtree(int L,int R,int now)
{
    tr[now].l=L;
    tr[now].r=R;
    tr[now].mul=1;
    if(L==R)
    {
        scanf("%lld",&tr[now].sum);
        return;
    }
    int mid=(L+R)>>1;
    buildtree(L,mid,now<<1);
    buildtree(mid+1,R,now<<1|1);
    pushup(now);
}
void pushdown(int now)
{
    tr[now<<1].mul=(tr[now<<1].mul*tr[now].mul)%p;
    tr[now<<1|1].mul=(tr[now<<1|1].mul*tr[now].mul)%p;
    tr[now<<1].lazy=(tr[now<<1].lazy*tr[now].mul+tr[now].lazy)%p;
    tr[now<<1|1].lazy=(tr[now<<1|1].lazy*tr[now].mul+tr[now].lazy)%p;
    tr[now<<1].sum=(tr[now<<1].sum*tr[now].mul+(tr[now<<1].r-tr[now<<1].l+1)*tr[now].lazy)%p;
    tr[now<<1|1].sum=(tr[now<<1|1].sum*tr[now].mul+(tr[now<<1|1].r-tr[now<<1|1].l+1)*tr[now].lazy)%p;
    tr[now].lazy=0;
    tr[now].mul=1;
}
void update(int L,int R,int now,ll val)
{
    if(tr[now].l==L&&tr[now].r==R)
    {
        tr[now].lazy=(tr[now].lazy+val)%p;
        tr[now].sum=(tr[now].sum+(tr[now].r-tr[now].l+1)*val)%p;
        return;
    }
    if(tr[now].lazy||tr[now].mul!=1) pushdown(now);
    int mid=(tr[now].l+tr[now].r)>>1;
    if(L>mid) update(L,R,now<<1|1,val);
    else if(mid>=R) update(L,R,now<<1,val);
    else
    {
        update(L,mid,now<<1,val);
        update(mid+1,R,now<<1|1,val);
    }
    pushup(now);
}
void multi(int L,int R,int now,ll val)
{
    if(tr[now].l==L&&tr[now].r==R)
    {
        tr[now].lazy=(tr[now].lazy*val)%p;
        tr[now].mul=(tr[now].mul*val)%p;
        tr[now].sum=(tr[now].sum*val)%p;
        return;
    }
    if(tr[now].lazy||tr[now].mul!=1) pushdown(now);
    int mid=(tr[now].l+tr[now].r)>>1;
    if(L>mid) multi(L,R,now<<1|1,val);
    else if(mid>=R) multi(L,R,now<<1,val);
    else
    {
        multi(L,mid,now<<1,val);
        multi(mid+1,R,now<<1|1,val);
    }
    pushup(now);
}
void check(int L,int R,int now)
{
    if(tr[now].l==L&&tr[now].r==R)
    {
        ans=(tr[now].sum+ans)%p;
        return;
    }
    if(tr[now].lazy||tr[now].mul!=1) pushdown(now);
    int mid=(tr[now].l+tr[now].r)>>1;
    if(L>mid) check(L,R,now<<1|1);
    else if(mid>=R) check(L,R,now<<1);
    else
    {
        check(L,mid,now<<1);
        check(mid+1,R,now<<1|1);
    }
    pushup(now);
}
int main()
{
    ll k;
    scanf("%d%d%lld",&n,&m,&p);
    buildtree(1,n,1);
    for(int i=1,cas,x,y;i<=m;i++)
    {
        scanf("%d%d%d",&cas,&x,&y);
        if(cas==1)
        {
            scanf("%lld",&k);
            multi(x,y,1,k);
        }
        else if(cas==2)
        {
            scanf("%lld",&k);
            update(x,y,1,k);
        }
        else{
           ans=0;
            check(x,y,1);
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```



#### 成端更新：注意有累加有覆盖

```c++
void pushup(int rt)
{
    val[rt] = val[rt<<1] + val[rt<<1|1];
}
void pushdown(int rt,int m)
{
    if (lz[rt])
    {
        lz[rt<<1] = lz[rt<<1|1] = lz[rt];
        val[rt<<1] = (m - (m>>1))*lz[rt];//左边是[1,m/2]有m-m/2个
        val[rt<<1|1] = (m>>1)*lz[rt];//右边[m/2+1,m]有m/2个
        lz[rt] = 0;
    }
}
 
void build(int l,int r,int rt)
{
    lz[rt] = 0;
    if (l == r)
    {
        val[rt] = 1;
        return ;
    }
    int m = (l + r)>>1;
    build(l,m,rt<<1);
    build(m + 1,r,rt<<1|1);
    pushup(rt);
}
 
void update(int L,int R,int sc,int l,int r,int rt)
{
    if (l >= L && r <= R)
    {
        lz[rt] = sc;
        val[rt] = lz[rt]*(r - l + 1);
        return ;
    }
    pushdown(rt,r - l + 1);
    int m = (l + r)>>1;
    if (L <= m) update(L,R,sc,l,m,rt<<1);
    if (R > m) update(L,R,sc,m + 1,r,rt<<1|1);
    pushup(rt);
}
```

#### 区间合并：

```c++
void pushup(int rt)
{
    //如果不存在区间合并的话正常的更新
    p[rt].lm = p[rt<<1].lm;
    p[rt].rm = p[rt<<1|1].rm;
    p[rt].sm = max(p[rt<<1].sm,p[rt<<1|1].sm);
    int m = (p[rt].l + p[rt].r)>>1;
    //存在可合并的区间
    if (val[m] < val[m + 1])
    {
        int L = m - p[rt].l + 1;
        int R = p[rt].r - m;
        if (p[rt<<1].lm == L) p[rt].lm += p[rt<<1|1].lm;
        if (p[rt<<1|1].rm == R) p[rt].rm += p[rt<<1].rm;
        p[rt].sm = max(p[rt].sm,p[rt<<1].rm + p[rt<<1|1].lm);
    }
}
void build(int l,int r,int rt)
{
   p[rt].l = l; p[rt].r = r;
   p[rt].lm = p[rt].rm = p[rt].sm = 1;
   if (l == r)
   {
       scanf("%d",&val[l]);
       return ;
   }
   int m = (l + r)>>1;
   build(l,m,rt<<1);
   build(m + 1,r,rt<<1|1);
   pushup(rt);
}
void update(int pos,int sc,int rt)
{
    if (p[rt].l == p[rt].r)
    {
        val[p[rt].l] = sc;
        return ;
    }
    int m = (p[rt].l + p[rt].r)>>1;
    if (pos <= m) update(pos,sc,rt<<1);
    else update(pos,sc,rt<<1|1);
    pushup(rt);

}

int query(int L,int R,int rt)
{
    if (p[rt].l >= L && p[rt].r <= R) return p[rt].sm;
    int m = (p[rt].l + p[rt].r)>>1;
    int res = 0;
    if (L <= m) res = max(res,query(L,R,rt<<1));
    if (R > m) res = max(res,query(L,R,rt<<1|1));
    //分出的两个小区间可以合并，记住这里有L，R左右临界的限制。
    if (val[m] < val[m + 1])
    res = max(res,min(m - L + 1,p[rt<<1].rm) + min(R - m,p[rt<<1|1].lm));
    return res;
}
lcs
同上，只不过在处理区间合并的判断条件时有所不同，上题因为每次都能更新到叶节点所以不必担心lz标记还没更新下来这一说。而这里lz大多数情况下不能更新到叶节点也就导致在判断区间合并的条件时产生了难点，才开始的时候我记录了每个树上节点总共加了多少add[rt]，样例过了可是老是wa无语了，后来想了想，如果我的子区间被更新后那么我只记录了子区间加了多少，而区间没有被更新，所以add记录的就是错误的信息了。

这里我们记录每个区间的左右点的值，每次更新的时候往上更新就好了，这样就保证了每个区间的左右端点值的正确性，因为我们在区间合并时需要的只是端点。
struct node{
    int lm,rm,sm;
    int l,r;
    int al,ar;//这里记录左右端点信息
    int mid(){
        return (l + r)>>1;
    }
}tre[N<<2];
int val[N],lz[N<<2],add[N<<2];

void pushup(int rt,int Ls,int Rs,int m){
    tre[rt].lm = tre[rt<<1].lm;
    tre[rt].rm = tre[rt<<1|1].rm;
    tre[rt].sm = max(tre[rt<<1].sm,tre[rt<<1|1].sm);
    tre[rt].al = tre[rt<<1].al; tre[rt].ar = tre[rt<<1|1].ar;

    if (tre[rt<<1].ar < tre[rt<<1|1].al){
        if (tre[rt].lm == Ls) tre[rt].lm += tre[rt<<1|1].lm;
        if (tre[rt].rm == Rs) tre[rt].rm += tre[rt<<1].rm;
        tre[rt].sm = max(tre[rt].sm,tre[rt<<1].rm + tre[rt<<1|1].lm);
    }
}
void pushdown(int rt){
    if (lz[rt] != 0){
        lz[rt<<1] += lz[rt];
        lz[rt<<1|1] += lz[rt];
        tre[rt<<1].al += lz[rt];
        tre[rt<<1].ar += lz[rt];
        tre[rt<<1|1].al += lz[rt];
        tre[rt<<1|1].ar += lz[rt];
        lz[rt] = 0;
    }
}
void build(int l,int r,int rt){
    lz[rt] = 0;
    tre[rt].l = l; tre[rt].r = r;
    tre[rt].ar = tre[rt].al = 0;
    if (l == r){
        tre[rt].lm = tre[rt].rm = tre[rt].sm = 1;
        scanf("%d",&tre[rt].al);
        tre[rt].ar = tre[rt].al;
        return ;
    }
    int m = tre[rt].mid();
    build(lc);
    build(rc);
    pushup(rt,m - l + 1,r - m,m);
}
void update(int L,int R,int sc,int rt){
    if (tre[rt].l >= L && tre[rt].r <= R){
        lz[rt] += sc;
        tre[rt].al += sc;
        tre[rt].ar += sc;
        return ;
    }
    int m = tre[rt].mid();
    pushdown(rt);
    if (L <= m) update(L,R,sc,rt<<1);
    if (R > m) update(L,R,sc,rt<<1|1);
    pushup(rt,m - tre[rt].l + 1,tre[rt].r - m,m);
}
int query(int L,int R,int rt){
    if (tre[rt].l >= L && tre[rt].r <= R){
        return tre[rt].sm;
    }
    pushdown(rt);
    int res = 0;
    int m = tre[rt].mid();
    if (L <= m) res = max(res,query(L,R,rt<<1));
    if (R > m) res = max(res,query(L,R,rt<<1|1));
    if (tre[rt<<1].ar < tre[rt<<1|1].al){
        res = max(res,min(m - L + 1,tre[rt<<1].rm) + min(R - m,tre[rt<<1|1].lm));
    }
    pushup(rt,m - tre[rt].l + 1,tre[rt].r - m,m);
    return res;
}

int main(){
    //freopen("data.in","r",stdin);
    int cas = 1;
    int T,n,q;
    char op[3];
    int x,y,z;
    scanf("%d",&T);
    while (T--){
        printf("Case #%d:\n",cas++);
        scanf("%d%d",&n,&q);
        build(1,n,1);
        while (q--){
            scanf("%s%d%d",op,&x,&y);
            if (op[0] == 'a'){
                scanf("%d",&z);
                update(x,y,z,1);
            }
            else{
                printf("%d\n",query(x,y,1));
            }
        }
    }
    return 0;
}
```



#### 扫描线模板:

##### 矩形面积并：

```c++
struct Seg{
    double l,r,h;
    int mk;
    Seg(){}
    Seg(double L,double R,double H,int MK){
        l = L; r = R; h = H; mk = MK;
    }
    bool operator < (const Seg &tmp) const{
        return h < tmp.h;
    }
}seg[N];

int cnt[N<<2];
double sum[N<<2],X[N];

void pushup(int rt,int l,int r){
    if (cnt[rt]) sum[rt] = X[r + 1] - X[l];//下边比上边多此区间仍满足条件
    else if (l == r) sum[rt] = 0;//单个的一条线段且x长度不满足条件肯定为0
    else sum[rt] = sum[rt<<1] + sum[rt<<1|1];//x不满足条件但其子树可能存在满足条件的
}
void update(int L,int R,int sc,int l,int r,int rt){
    if (L <= l && r <= R){
        cnt[rt] += sc;//更新
        pushup(rt,l,r);
        return ;
    }
    int m = (l + r)>>1;
    if (L <= m) update(L,R,sc,lc);
    if (m < R) update(L,R,sc,rc);
    pushup(rt,l,r);
}
//离散化后二分查找
int bSearch(double val,int n){
    int l = 0;
    int r = n;
    while (l <= r){
        int m = (l + r)>>1;
        if (val == X[m]) return m;
        else if (val < X[m]) r = m - 1;
        else l = m + 1;
    }
    return l;
}
for (i = 0; i < len - 1; ++i){
            int l = bSearch(seg[i].l,k - 1);
            int r = bSearch(seg[i].r,k - 1) - 1;//这里讲点转化成线段（难理解）
            if (l <= r) update(l,r,seg[i].mk,0,k - 2,1);
            res += sum[1]*(seg[i + 1].h - seg[i].h);//sum[1]记录整个区间满足条件的x的长度
        }
```



##### 矩形周长并：

```c++
struct Seg{
    int l,r,h;
    int mk;
    Seg(){}
    Seg(int L,int R,int H,int MK){
        l = L; r = R; h = H; mk = MK;
    }
    bool operator < (const Seg &tmp) const{
        return h < tmp.h;
    }
}seg[M];

int len[N<<2],cnt[N<<2],numseg[N<<2];
int lbd[N<<2],rbd[N<<2];

void pushup(int rt,int l,int r){
    if (cnt[rt]){
        len[rt] = r - l + 1;
        lbd[rt] = rbd[rt] = 1;//标记边界
        numseg[rt] = 2;
    }
    else if (l == r) len[rt] = lbd[rt] = rbd[rt] = numseg[rt] = 0;
    else{
        len[rt] = len[rt<<1] + len[rt<<1|1];
        numseg[rt] = numseg[rt<<1] + numseg[rt<<1|1];
        lbd[rt] = lbd[rt<<1];
        rbd[rt] = rbd[rt<<1|1];
        if (lbd[rt<<1|1] && rbd[rt<<1]) numseg[rt] -= 2;//边界重合重合
    }
}
void update(int L,int R,int sc,int l,int r,int rt){
    if (L <= l && r <= R){
        cnt[rt] += sc;
        pushup(rt,l,r);
        return ;
    }
    int m = (l + r)>>1;
    if (L <= m) update(L,R,sc,lc);
    if (m < R) update(L,R,sc,rc);
    pushup(rt,l,r);
}
for (i = 0; i < m; ++i){
        if (seg[i].l < seg[i].r)
        update(seg[i].l,seg[i].r - 1,seg[i].mk,L,R - 1,1);
        res += numseg[1]*(seg[i + 1].h - seg[i].h);//竖直方向上有效长度
        res += iabs(len[1] - last);//水平方向上的长度
        last = len[1];//last记录上次的横向的有效长度
}
```



##### 线段树区间部分更新

给出三种操作add x 向集合里添加x（这里保证集合中不存在该元素）, del x删除集合里的x（这里保证集合里面不存在x），

![图片3](/home/heng/图片3.png)



然后给出N个操作，输出每次的sum；

**思路：**

才开始看到这题就想到了上次那个维护区间（i-a）%k == 0的题目区间部分更新的题目，每个线段树上的节点添加记录该区间内模k余(0到k-1)的值，可是这里是求整个区间，而且一旦删除一个值它们原来满足模k的余数就会发生改变。直接就晕了。。。看了下解题报告原来和上次的题目是类似的，我们还是记录当前区间模5余（0到4）的值，只是稍微进行一下区间合并即可，解题的关键就在于这里的区间合并。当向上更新的时候当前节点的左子树模5余数不变，只要加上就好，而对于右子树由于在该区间的前边又添加len[rt<<1]这些长度的值，所以原来他们模5的余数对于整体的父亲节点来说已经改变了我们只要右子树模5等于i的现在对应于父亲节点为模5等与（len[rt<<1] + i ）%5.然后合并完毕了。。



==离散化+离线处理 +区间合并==

```c++
ll Mod[N<<2][5];
int len[N<<2];
int val[N],a[N];
char op[N][5];

void pushup(int rt){
    int i;
    len[rt] = len[rt<<1] + len[rt<<1|1];
    //关键理解合并
    for (i = 0; i < 5; ++i) Mod[rt][i] = Mod[rt<<1][i];
    int Lx = len[rt<<1];
    for (i = 0; i < 5; ++i) Mod[rt][(Lx + i)%5] += Mod[rt<<1|1][i];
}
void build(int l,int r,int rt){
    for (int i = 0; i < 5; ++i) Mod[rt][i] = 0;
    len[rt] = 0;
    if (l == r) return ;
    int m = (l + r)>>1;
    build(lc);
    build(rc);
}
void update(int pos,int sc,int l,int r,int rt){
    if (l == r){
        len[rt] += sc;
        Mod[rt][1] += sc*a[l];//对于一个叶子节点来说区间是[1,1]所以模5等于1
        return ;
    }
    int m = (l + r)>>1;
    if (pos <= m) update(pos,sc,lc);
    else update(pos,sc,rc);
    pushup(rt);
}
int bSearch(int L,int R,int v){
    int l = L;
    int r = R;
    while (l <= r){
        int m = (l + r)>>1;
        if (a[m] == v) return m;
        else if (v < a[m]) r = m - 1;
        else l = m + 1;
    }
    return -1;
}
int main(){
    //freopen("din.txt","r",stdin);
    int i,n;
    while (~scanf("%d",&n)){
        int ct = 0;
        for (i = 0; i < n; ++i){
            scanf("%s",op[i]);
            if (op[i][0] != 's'){
                scanf("%d",&val[i]);
                a[++ct] = val[i];
            }
        }
        //离散化
        sort(a + 1,a + 1 + ct);
        int nn = 1;
        for (i = 2; i <= ct; ++i){
            if (a[i] != a[i - 1]) a[++nn] = a[i];
        }
        //离线处理
        build(1,nn,1);
        for (i = 0; i < n; ++i){
            if (op[i][0] == 'a') update(bSearch(1,nn,val[i]),1,1,nn,1);
            else if (op[i][0] == 'd') update(bSearch(1,nn,val[i]),-1,1,nn,1);
            else printf("%I64d\n",Mod[1][3]);
        }
    }
    return 0;
}
```



给你N个数，有两种操作：

2 x询问a[x]的值；

1 a b k c   a <= i <= b 满足(i - a)%k == 0的a[i] += c; 

(1 <= N <= 50000) (1 <= a <= b <= N, 1 <= k <= 10, -1,000 <= c <= 1,000)

 

**思路：**

 

一看就知道这肯定是线段树的题目，可是区间内满足(i - a)%k == 0的点才进行处理怎么办，如果i i + k,i + 2k的循环处理的话，就都变成的了单点更新了，时间复杂度O(n^2)就不行可。 

这里肯定要优化到O(nlogn)，才开始想记录1操作，区间[a,b]按平常加，每次询问点时再枚举所有的1减去多加了，发现只能优化到O(n^2/2)写了一下TLE.后来看了解题报告才恍然大悟。

线段树上的每个点表示一个区间，我们记录该区间所有模i于j的点的值,由于1 <= k <= 10 所以总共有55中可能，把每个区间的所有可能记录，然后区间更新时，只要将该区间所有满足的情况累加一边就好了，单点询问的话只需要将所有情况累加即可。

```c++
i%k = a%k;
struct node{
    int l,r;
    int mod[55];//记录模k的各种情况
    int lz;
    int mid(){
       return (l + r)>>1;
    }
}a[4*N];
int mk[11][11],b[N];

void init(){
    int i,j;
    int ct = 0;
    for (i = 1; i <= 10; ++i){
        for (j = 0; j < i; ++j)
        mk[i][j] = ct++;//将其转变为1维
    }
}
void pushdown(int rt){
    if (a[rt].lz){
        a[rt<<1].lz += a[rt].lz;
        a[rt<<1|1].lz += a[rt].lz;
        a[rt].lz = 0;
        for (int i = 0; i < 55; ++i){
            a[rt<<1].mod[i] += a[rt].mod[i];
            a[rt<<1|1].mod[i] += a[rt].mod[i];
            a[rt].mod[i] = 0;
        }
    }
}
void build(int l,int r,int rt){
    a[rt].l = l; a[rt].r = r;
    a[rt].lz = 0;
    CL(a[rt].mod,0);
    if (l == r) return;
    int m = a[rt].mid();
    build(lc);
    build(rc);
}
void update(int L,int R,int k,int MOD,int sc,int rt){
    if (a[rt].l >= L && a[rt].r <= R){
        a[rt].lz += sc;
        a[rt].mod[mk[k][MOD]] += sc;//模k等于MOD的累加
        return;
    }
    pushdown(rt);
    int m = a[rt].mid();
    if (L <= m) update(L,R,k,MOD,sc,rt<<1);
    if (R > m) update(L,R,k,MOD,sc,rt<<1|1);
}
int query(int pos,int rt){
    if (a[rt].l == a[rt].r){
        int tmp = 0;
        for (int i = 1; i <= 10; ++i){
            tmp += a[rt].mod[mk[i][pos%i]];//枚举当前点模1-10的所有可能
        }
        return b[a[rt].l] + tmp;
    }
    pushdown(rt);
    int res = 0;
    int m = a[rt].mid();
    if (pos <= m) res = query(pos,rt<<1);
    else res = query(pos,rt<<1|1);
    return res;
}
int main(){
    //freopen("din.txt","r",stdin);
    int i,n,m;
    int op,x,y,c,k;
    init();
    while (~scanf("%d",&n)){
        for (i = 1; i <= n; ++i) scanf("%d",&b[i]);
        build(1,n,1);
        scanf("%d",&m);
        while (m--){
            scanf("%d",&op);
            if (op == 2){
                scanf("%d",&x);
                printf("%d\n",query(x,1));
            }
            else{
                scanf("%d%d%d%d",&x,&y,&k,&c);
                update(x,y,k,x%k,c,1);
            }
        }
    }
    return 0;
}
```



#### 划分树模板:

##### 1求区间第**K**大的数

```c++
struct node{
    int l,r;
    int mid(){
        return (l + r)>>1;
    }
}tt[N<<2];

int toLeft[20][N];
int val[20][N],sorted[N];
int n,q;

void build(int l,int r,int rt,int d){
    int i;
    tt[rt].l = l;
    tt[rt].r = r;
    if (l == r) return ;
    int m = tt[rt].mid();
    int lsame = m - l + 1;//先假设做区间与m相等的放满
    //一一排除，保证左区间放的是<=sorted[m]的值
    for (i = l; i <= r; ++i){
        if (val[d][i] < sorted[m]) lsame--;
    }

    int lpos = l;
    int rpos = m + 1;
    int same = 0;

    for (i = l; i <= r; ++i){
        if (i == l) toLeft[d][i] = 0;//toLeft[i]表示[ tt[rt].l , i ]区域里有多少个数分到左边
        else toLeft[d][i] = toLeft[d][i - 1];

        if (val[d][i] < sorted[m]){
            toLeft[d][i]++;
            val[d + 1][lpos++] = val[d][i];
        }
        else if (val[d][i] > sorted[m]){
            val[d + 1][rpos++] = val[d][i];
        }
        else{
            if (same < lsame){//有lsame的数是分到左边的
                toLeft[d][i]++;
                val[d + 1][lpos++] = val[d][i];
                same++;
            }
            else{
                val[d + 1][rpos++] = val[d][i];
            }
		}
    }
    build(lc,d + 1);
    build(rc,d + 1);
}

int query(int L,int R,int k,int d,int rt){
   // printf("%d %d\n",L,R);
    if (L == R){
        return val[d][L];
    }
    int s = 0;;//s表示[ L , R ]有多少个分到左边
    int ss = 0;//ss表示 [tt[rt].l , L-1 ]有多少个分到左边
    if (L == tt[rt].l){
        ss = 0;
        s = toLeft[d][R];
    }
    else{
        ss = toLeft[d][L - 1];
        s = toLeft[d][R] - toLeft[d][L - 1];
    }
    if (k <= s){//有多于k个分到左边,显然去左儿子区间找第k个
        int newl = tt[rt].l + ss;
        int newr = newl + s - 1;
        return query(newl,newr,k,d + 1,rt<<1);
    }
    else{
        int m = tt[rt].mid();
        int bb = L - tt[rt].l - ss;//bb表示 [tt[rt].l , L-1 ]有多少个分到右边
        int b = R - L + 1 - s;//b表示 [L , R]有多少个分到右边
        int newl = m + bb + 1;
        int newr = newl + b - 1;
        return query(newl,newr,k - s,d + 1,rt<<1|1);
    }
}
```



**题意：**

给定一个长度为n的序列，求区间[L,R]中小于h的个数；

**思路：**

分三种情况：

1：如果该区间最小值都大于h输出0；

2：如果该区间最大值小于等于h输出区间长度：

3：否则，二分枚举该区间的第m大，直到找到第m大为最后一个小于等于h的；

```c++
struct node{
    int l,r;
    int mid(){
        return (l + r)>>1;
    }
}tt[N<<2];

int toLeft[20][N],val[20][N];
int sorted[N];
int n,m;
int MIN,MAX;

void build(int l,int r,int rt,int d){
    int i;
    tt[rt].l = l;
    tt[rt].r = r;
    if (l == r) return ;
    int m = tt[rt].mid();
    int lsame = m - l + 1;
    for (i = l; i <= r; ++i){
        if (val[d][i] < sorted[m]) lsame--;
    }

    int lpos = l,rpos = m + 1;
    int same = 0;
    for (i = l; i <= r; ++i){
        if (i == l) toLeft[d][i] = 0;
        else toLeft[d][i] = toLeft[d][i - 1];

        if (val[d][i] < sorted[m]){
            toLeft[d][i]++;
            val[d + 1][lpos++] = val[d][i];
        }
        else if (val[d][i] > sorted[m]){
            val[d + 1][rpos++] = val[d][i];
        }
        else{
            if (same < lsame){
                same++;
                val[d + 1][lpos++] = val[d][i];
                toLeft[d][i]++;
            }
            else{
                val[d + 1][rpos++] = val[d][i];
            }
        }
    }
    build(lc,d + 1);
    build(rc,d + 1);
}
int query(int L,int R,int k,int d,int rt){
    if (L == R) return val[d][L];
    int s,ss;
    if (L == tt[rt].l){
        ss = 0;
        s = toLeft[d][R];
    }
    else{
        ss = toLeft[d][L - 1];
        s = toLeft[d][R] - toLeft[d][L - 1];
    }

    if (s >= k){
        int newl = tt[rt].l + ss;
        int newr = newl + s - 1;
        return query(newl,newr,k,d + 1,rt<<1);
    }
    else{
        int m = tt[rt].mid();
        int bb = L - tt[rt].l - ss;
        int b = R - L + 1 - s;
        int newl = m + bb + 1;
        int newr = newl + b - 1;
        return query(newl,newr,k - s,d + 1,rt<<1|1);
    }
}
int bSearch(int l,int r,int h,int x,int y){
    int ans = 0;
    while (l <= r){
        int m = (l + r)>>1;
        if (query(x,y,m,0,1) > h)
        r = m - 1;
        else{
            l = m + 1;
            ans = m;
        }
    }
    return ans;
}
int Input(){
    char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    int num = 0;
    while (ch >= '0' && ch <= '9'){
        num = num*10 + ch - '0';
        ch = getchar();
    }
    return num;
}
int main(){
    //freopen("din.txt","r",stdin);
    int t,i;
    int x,y,h;
    int cas = 1;
    t = Input();
    while (t--){
        printf("Case %d:\n",cas++);
        n = Input();
        m = Input();
        for (i = 1; i <= n; ++i){
            val[0][i] = Input();
            sorted[i] = val[0][i];
        }
        sort(sorted + 1,sorted + 1 + n);
        build(1,n,1,0);
        while (m--){
            x = Input();
            y = Input();
            h = Input();
            x++; y++;
            MIN = 1;
            MAX = y - x + 1;
            if (query(x,y,MIN,0,1) > h) puts("0");
            else if (query(x,y,MAX,0,1) <= h) printf("%d\n",MAX);
            else{
                int pos = bSearch(MIN,MAX,h,x,y);
                printf("%d\n",pos);
            }
        }
    }
    return 0;
}
```



给定一个长度为n的序列，求区间[l,r]内的一个点值为x，使得最小。 

**思路：**

很多解题报告都说找出区间**[l,r]**的中位数即可，可是我百度了一下中位数，他的定义是这样的：

当变量值的项数**N**为奇数时，处于中间位置的变量值即为中位数；当**N**为偶数时，中位数则为处于中间位置的**2**个变量值的平均数，也即当**N**为偶数时，中位数就不一定属于该序列了。所以这里不是求得中位数。

而是当**N**为奇数时得到中位数**k**，偶数时**N/2(k)**位置的那个数，也即这里保证x来自该序列。然后利用划分树求出区间**[l,r]**中小于**k**的个数以及他们的和，然后利用公式计算即可

---

# 图论：

## 图的邻接表的两种实现方式

### 链表:

```c++
struct node {
    int v; //边的结束顶点
    int w; //边的长度
    node* next; //指向以同一起点的下一条边的指针
}*head[N], H[M]; //head[u]指向以u为起始点的第一条边

void init() {
    memset(head,NULL,sizeof(head));
}

void add(int u, int v, int w) { //添加边
    node* p = &H[tt++]//new node;
    p->v = v;
    p->w = w;
    p->next = head[u];
    head[u] = p;
}

//使用的时候，找u的邻接点
for (node* p = head[u]; p != NULL; p = p->next) {
   int v = p -> v;
   //在这里作相应的处理
   indegree[v]--;
}

```

### 边表：

```c++
struct node {
   int u, v, w;
   int next;
}g[M]; //作为静态内存来使用，速度快
int head[N], t = 0;
void init() {
   t = 0;
   memset(head, -1, sizeof(head));
}

void add (int u, int v, int w) { //添加边
   g[t].u = u;
   g[t].v = v;
   g[t].w = w;
   g[t].next = head[u];
   head[u] = t;
   t++;  //为下一次做准备
}

//使用的时候，找u的邻接点
for (int = head[u]; i != -1; i = g[i].next) {
   int v = g[i].v;
   //在这里作相应的处理
   indegree[v]--;
}


```

## 最短路:

### Spfa

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<map>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#define N 500010
#define inf 2147483647
using namespace std;
struct edge{
    int nxt,to,w;
}e[N];
bool vis[N];
int dis[N],head[N],tot,n,m,s;
queue<int> q;
inline int read()
{
    int x=0,f=0;
    char ch=getchar();
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return f?-x:x;
}
inline void add(int u,int v,int w)
{
    e[++tot].to=v;
    e[tot].nxt=head[u];
    e[tot].w=w;
    head[u]=tot;
}
inline void spfa(int s)
{
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=false;
        for(int i=head[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if(dis[v]&&dis[v]>dis[u]+e[i].w)
            {
                dis[v]=dis[u]+e[i].w;
                if(!vis[v])
                {
                    vis[v]=true;
                    q.push(v); 
                }
            }
        }
    }
}
int main()
{
    n=read();m=read();s=read();
    for(int i=1,u,v,w;i<=m;i++)
    {
        u=read();v=read();w=read();
        add(u,v,w);
    }
    for(int i=1;i<=n;i++)
    {
        vis[i]=false;
        dis[i]=inf;
    }
    q.push(s);
    vis[s]=true;
    dis[s]=0;
    spfa(s);
    for(int i=1;i<=n;i++)
        printf("%d ",dis[i]);
    return 0;
}
```



### Dijkstra

```c++
int mp[N][N];
int dis[N],pre[N],path[N];
bool vt[N];
int n,m;

void init(){
    int i,j;
    for (i = 0; i <= n; ++i){
        for (j = 0; j <= n; ++j){
            mp[i][j] = (i != j)*inf;
        }
    }
}
void Dijkstra(int s){
    int i,j,k;
    for (i = 0; i < n; ++i){
        dis[i] = mp[s][i];
        if (dis[i] == inf) pre[i] = -1;
        else pre[i] = s;
        vt[i] = false;
    }
    dis[s] = 0; vt[s] = true;

    for (k = 1; k < n; ++k){
        int MIN = inf;
        for (i = 0; i < n; ++i){
            if (!vt[i] && dis[i] < MIN){
                MIN = dis[i];
                j = i;
            }
        }
        vt[j] = true;
        for (i = 0; i < n; ++i){
            if (!vt[i] && dis[i] > dis[j] + mp[j][i]){
                dis[i] = dis[j] + mp[j][i];
                pre[i] = j;
            }
        }
    }
    printf(">>>%d\n",dis[n - 1]);
}
//输出最短路径
void ptintPath(int s,int e){
    int tot = 0,i;
    path[tot++] = e;
    int v = pre[e];
    while (v != s){
        path[tot++] = v;
        v = pre[v];
    }
    path[tot++] = s;
    printf("%d\n",tot);
    for (i = tot - 1; i >= 0; --i) printf("%d->",path[i]);
    printf("\n");
}
```



### Belllman_ford:

```c++
void relax(int u, int v, int weight){
    if(dist[v] > dist[u] + weight)
        dist[v] = dist[u] + weight;
}
bool Bellman_Ford(){
    for(int i=1; i<=nodenum-1; ++i)
        for(int j=1; j<=edgenum; ++j)
            relax(edge[j].u, edge[j].v, edge[j].weight);
    bool flag = 1;
    // 判断是否有负环路
    for(int i=1; i<=edgenum; ++i)
        if(dist[edge[i].v] > dist[edge[i].u] + edge[i].weight)
        {
            flag = 0;
            break;
        }
    return flag;
}
```



### Floyd

```c++
void floyd() {
    int i,j,k;
    for (k = 0; k < n; ++k){
        for (i = 0; i < n; ++i){
            for (j = 0; j < n; ++j){
                if (map[i][k] != inf && map[k][j] != inf
                    && map[i][k] + map[k][j] < map[i][j])
                map[i][j] = map[i][k]*map[k][j];
            }
        }
    }
}
```



### 最小生成树:

假设 $n$ 表示图中点数，$m$ 表示图中边数。

#### Prim算法：

适用于稠密图，时间复杂度 $O(n^2)$。

核心思想：每次挑一条与当前集合相连的最短边。

```c++
// st[i] 表示点i是否在当前生成树集合中
// dist[i] 表示点i到当前集合的最短边的长度
// g[i][j] 表示点i和点j之间边的长度
// 返回值：最小生成树中所有边的总长度
int Prim()
{
    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        dist[i] = INF;
        st[i] = false;
    }
    dist[1] = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int id = -1, min_dist = INF;
        // 寻找最短边
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && dist[j] < min_dist)
            {
                id = j;
                min_dist = dist[j];
            }
        st[id] = true;
        res += dist[id];
        // 用新加入的点更新其余点到生成树的最短边
        for (int j = 1; j <= n; j ++ )
            if (!st[j])
                dist[j] = min(dist[j], g[id][j]);
    }
    return res;
}


```



#### Kruskal

适用于稀疏图，时间复杂度 $O(mlogm)$。

核心思想：从小到大挑不多余的边。

```c++
// 边的信息
struct Edge
{
    int a, b, v;
    bool operator< (const Edge &W) const
    {
        return v < W.v;
    }
};

// 并查集——寻找当前集合的代表元素
int find(int x)
{
    if (father[x] != x) father[x] = find(father[x]);
    return father[x];
}

// 所有边存储在 Edge edges[M]; 
// 函数返回最小生成树中所有边的总长度
int Kruskal()
{
    int res = 0;
    // 初始化并查集代表元素
    for (int i = 1; i <= n; i ++ ) father[i] = i;
    sort(edge, edge + m);
    for (int i = 0; i < m; i ++ )
    {
        int a = edge[i].a, b = edge[i].b;
        if (find(a) != find(b))
        {
            res += edge[i].v;
            father[find(a)] = find(b);
        }
    }
    return res;
}


```



### 次小生成树

次小生成树，顾名思义就是在所有的生成树中第二小的生成树，（最小的当然是最小生成树了，废话了），话说求次小生成树有两种方法：

1：首先求出最小生成树T，然后枚举最小生成树上的边，计算除了枚举的当前最小生成树的边以外的所有边形成的最小生成树Ti，然后求最小的Ti就是次小生成树。

2：首先计算出最小生成树T，然后对最小生成树上任意不相邻的两个点 （i,j）添加最小生成树以外的存在的边形成环，然后寻找i与j之间最小生成树上最长的边删去，计算map[i][j]（最小生成树以外存在的边） 与 maxd[i][j]（最小生成树上最长的边）差值，求出最小的来，w(T)再加上最小的差值就是次小生成树了。

这道题的题意是：判断该图的最小生成树是否唯一，有两种办法；

1：求其最小生成树，如果最小生成树的长度与次小生成树的长度相等（这里只要判断最小差值是否为0即可），则不唯一。否则唯一。

#### 第一种：

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#define maxn 1007
#define inf 99999999
using namespace std;
int dis[maxn],map[maxn][maxn],maxd[maxn][maxn];
int pre[maxn],stack[maxn];
bool vt[maxn];
int n,m,ans;
void init()
{
    int i,j;
    for (i = 0; i < maxn; ++i)
    {
        for (j = 0; j < maxn; ++j)
        {
            if (i == j) map[i][j] = 0;
            else map[i][j] = inf;
            maxd[i][j] = -1;
        }
    }
}
void prim()
{
    int i,j,Min,k;
    int top = 0; ans = 0;
    for (i = 1; i <= n; ++i)
    {
        pre[i] = 1;//存放i的父节点
        dis[i] = map[1][i];
        vt[i] = false;
    }
    vt[1] = true;
    stack[top++] = 1;//存放已经加入最小生成树节点
   for (k = 1; k < n; ++k)
   {
       j = 1; Min = inf;
       for (i = 2; i <= n; ++i)
       {
           if (!vt[i] && dis[i] < Min)
           {
               j = i; Min = dis[i];
           }
       }
       vt[j] = true; ans += Min;
       //关键是这里运用DP求任意两点的最大边权
       for (i = 0; i < top; ++i)
       maxd[j][stack[i]] = maxd[stack[i]][j] = max(Min,maxd[stack[i]][pre[j]]);
       stack[top++] = j;
       for (i = 2; i <= n; ++i)
       {
           if (!vt[i] && dis[i] > map[i][j] && map[i][j] != inf)
           {
               dis[i] = map[i][j];
               pre[i] = j;//记录父节点
           }
       }
   }

}
int main()
{
    int i,j,t;
    int x,y,z;
    scanf("%d",&t);
    while (t--)
    {
        init();
        scanf("%d%d",&n,&m);
        for (i = 0; i < m; ++i)
        {
            scanf("%d%d%d",&x,&y,&z);
            map[x][y] = map[y][x] = z;
        }
        prim();
        int ct = inf;
        //循环加外边计算差值
        for (i = 1; i <= n; ++i)
        {
            for (j = 1; j <= n; ++j)
            {
                if (i != j && pre[j] != i && j != pre[i] && map[i][j] != inf)
                {
                    //printf(">>>%d %d\n",map[i][j],maxd[i][j]);
                    ct = min(map[i][j] - maxd[i][j],ct);
                }
            }
        }
        if (ct == 0) printf("Not Unique!\n");
        else         printf("%d\n",ans);
    }
}
```

#### 第二种:

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#define maxn 1007
#define inf 99999999
using namespace std;

int map[maxn][maxn],dis[maxn],ch[maxn];
bool vt[maxn];
int n,m,ans;

void init()
{
    int i,j;
    for (i = 0; i < maxn; ++i)
    {
        ch[i] = 0;
        for (j = 0; j < maxn; ++j)
        {
            map[i][j] = (i != j)*inf;
        }
    }
}
int prim()
{
    int i,j,min,k;
    for (i = 1; i <= n; ++i)
    {
        dis[i] = map[1][i];
        ch[i] = 1;//注意ch[i]的初始化
        vt[i] = false;
    }
    vt[1] = true; ans = 0;
    for (k = 1; k < n; ++k)
    {
        j = 1; min = inf;
        for (i = 2; i <= n; ++i)
        {
            if (!vt[i] && dis[i] < min)
            {
                j = i; min = dis[i];
            }
        }
        if (ch[j] >= 2) return -1;
        vt[j] = true;
        ans += min;
        //printf(">>>>%d %d\n",j,ch[j]);
        for (i = 2; i <= n; ++i)
        {
            if (!vt[i])
            {
                //如果有相同的更新++
                if (dis[i] == map[j][i] && map[j][i] != inf) ch[i]++;
                //首次更新
                else if (dis[i] > map[j][i] && map[j][i] != inf)
                {
                    dis[i] = map[j][i];
                    ch[i] = 1;
                }
            }
        }
    }
    return ans;
}
int main()
{
    int i,t;
    int x,y,z;
    scanf("%d",&t);
    while (t--)
    {
        init();
        scanf("%d%d",&n,&m);
        for (i = 0; i < m; ++i)
        {
            scanf("%d%d%d",&x,&y,&z);
            map[x][y] = map[y][x] = z;
        }
        int flag = prim();
        if (flag == -1) printf("Not Unique!\n");
        else       printf("%d\n",flag);
    }
    return 0;
}
```



### 匹配：

#### 二分匈牙利算法：

一个二分图中的最大匹配数等于这个图中的最小点覆盖数

最小路径覆盖＝｜G｜－最大匹配数

二分图最大独立集=顶点数-二分图最大匹配

```c++
int count = 0;
for (i = 1; i <= gn; ++i){
    memset(visit,false,sizeof(visit));
    if (dfs(i)) count++;
}
bool dfs(int rpos){
    int i;
    //对于集合gm循环遍历
    for(i = 1; i <= gm; ++i){
        //如果i与rpos有边&&i没被访问过
        if (!visit[i] && map[rpos][i]){
            visit[i] = true;
            if (link[i] == -1 || dfs(link[i]))
            //如果i与点集合gn中的点没有边，
            //没有参与匹配的边则找到一条增广路，
            //rpos到i存在没有参与匹配的边，
            //而i到link[i]存在参与匹配的边然后往后找直到找到增广路，
            //然后用M‘来代替M增加一条边
            {
                link [i] = rpos;
                return true;
            }
        }
    }
    return false;
}
```



### 最优权匹配KM算法：

#### O(n^4):

```c++
const int inf = 99999999;
int w[maxn][maxn],link[maxn];
int lx[maxn],ly[maxn];//记录顶标
bool vtx[maxn],vty[maxn];//记录X,Y点集是否被访问过
int nx,ny;

bool dfs(int i)
{
    int j;
    vtx[i] = true;//记住要标记
    for (j = 0; j < ny; ++j)
    {
        //按可行边超找增广轨
        if (!vty[j] && lx[i] + ly[j] == w[i][j])
        {
            vty[j] = true;
            if (link[j] == -1 || dfs(link[j]))
            {
                link[j] = i;
                return true;
            }
        }
    }
    return false;
}
int KM(){
    int i,j,k;
    //初始化X点集的顶标
    for (i = 0; i < nx; ++i){
        for (j = 0,lx[i] = -inf; j < ny; ++j){
            lx[i] = max(lx[i],w[i][j]);
        }
    }
    //初始化
    for (i = 0; i < maxn; ++i){
        link[i] = -1; ly[i] = 0;
    }
    for (i = 0; i < nx; ++i){
        while (1){
            for (j = 0; j < maxn; ++j) vtx[j] = vty[j] = false;
            if (dfs(i)) break;//找到增广轨跳出循环
            int d = inf;
            //寻找d
            for (j = 0; j < nx; ++j){
                if (vtx[j]){
                    for (k = 0; k < ny; ++k)
                    {
                        if (!vty[k]) d = min(d,lx[j] + ly[k] - w[j][k]);
                    }
                }
            }
            if (d == inf) return -1;//无完备匹配退出<br>　　　　　　　//在经过dfs后得到的交错树上进行加减d，因为在交错树上的都满足lx[i] +　ly[j] == w[i][j]加减后无影响。
            for (j = 0; j < nx; ++j) if (vtx[j]) lx[j] -= d;
            for (j = 0; j < ny; ++j) if (vty[j]) ly[j] += d;
        }
    }
    //计算最大带权匹配
    int sum = 0;
    for (i = 0; i < ny; ++i)
    if (link[i] > -1) sum += w[link[i]][i];
    return sum;
}
```



#### O(n^3):

```c++
bool dfs(int i){
   int j;
   vtx[i] = true;
   for (j = 0; j < ny; ++j){
       if (vty[j]) continue;
       int tmp = lx[i] + ly[j] - w[i][j];
       if (tmp == 0){
           vty[j] = true;
           if (link[j] == -1 || dfs(link[j]))
           {
               link[j] = i;
               return true;
           }
       }
       else
       slack[j] = min(slack[j],tmp);//更新松弛量
   }
   return false;
}

int KM(){
    int i,j;
    //初始化lx
    for (i = 0; i < nx; ++i){
        for (j = 0,lx[i] = -inf; j < ny; ++j)
        {
            lx[i] = min(lx[i],w[i][j]);
        }
    }
    for (i = 0; i < maxn; ++i){
        link[i] = -1; ly[i] = 0;
    }
    for (i = 0; i < nx; ++i){
        for (j = 0; j < ny; ++j) slack[j] = inf;//初始化松弛量
        while (1){
            for (j = 0; j < maxn; ++j) vtx[j] = vty[j] = false;
            if (dfs(i)) break;
            int d = inf;
            for (j = 0; j < ny; ++j)
            {
                if (!vty[j] && d > slack[j]) d = slack[j];
            }
            if (d == inf) return -1;
            for (j = 0; j < nx; ++j)
            if (vtx[j]) lx[j] -= d;
            for (j = 0; j < ny; ++j)
            if (vty[j]) ly[j] += d;
            else    slack[j] -= d;//注意松弛量的修改
        }
    }
    int sum = 0;
    for (i = 0; i < ny; ++i)
    if (link[i] > -1) sum += w[link[i]][i];
    return sum;
}
```



### Tarjan 算法系列：

1.割点：若删掉某点后，原连通图分裂为多个子图，则称该点为割点。

2.割点集合：在一个无向连通图中，如果有一个顶点集合，删除这个顶点集合，以及这个集合中所有顶点相关联的边以后，原图变成多个连通块，就称这个点集为割点集合。

3.点连通度：最小割点集合中的顶点数。

4.割边(桥)：删掉它之后，图必然会分裂为两个或两个以上的子图。

5.割边集合：如果有一个边集合，删除这个边集合以后，原图变成多个连通块，就称这个点集为割边集合。

6.边连通度：一个图的边连通度的定义为，最小割边集合中的边数。

7.缩点：把没有割边的连通子图缩为一个点，此时满足任意两点之间都有两条路径可达。

注：求块<>求缩点。缩点后变成一棵k个点k-1条割边连接成的树。而割点可以存在于多个块中。

8.双连通分量：分为点双连通和边双连通。它的标准定义为：点连通度大于1的图称为点双连通图，边连通度大于1的图称为边双连通图。通俗地讲，满足任意两点之间，能通过两条或两条以上没有任何重复边的路到达的图称为双连通图。无向图G的极大双连通子图称为双连通分量。

#### Tarjan求割点：

```c++
int low[maxn],dfn[maxn],cut[maxn],head[maxn];
void add(int u,int v){
    g[t].v = v;
    g[t].next = head[u];
    head[u] = t++;
}
void tarjan(int i){
    int j,k;
    low[i] = dfn[i] = ++index;
    for (k = head[i]; k; k = g[k].next){
        j = g[k].v;
        if(!dfn[j]){
            tarjan(j);
            if (i == root) rtson++;
            else{
                if (low[i] > low[j]) low[i] = low[j];
                if (low[j] >= dfn[i]) cut[i]++;//这里来记录割点及连通块数
            }
        }
        else if(low[i] > dfn[j]){
            low[i] = dfn[j];
        }
    }
}
```



#### Tarjan缩点：

```c++
void add(int u,int v){
    g[t].v = v;
    g[t].next = head[u];
    head[u] = t++;
}
void tarjan(int i){
    int j,k;
    low[i] = dfn[i] = ++index;
    instack[i] = true;
    stack[++top] = i;
    for (k = head[i]; k; k = g[k].next){
        j =g[k].v;
        if (!dfn[j]){
            tarjan(j);
            low[i] = min(low[i],low[j]);
        }
        else if(instack[j]){
            low[i] = min(low[i],dfn[j]);
        }
    }
    if (dfn[i] == low[i]){
        bcnt++;
        do
        {
            j = stack[top--];
            instack[j] = false;
            belong[j] = bcnt;//根据属性来缩点
        }while (j != i);
    }
}
```



#### Tarjan求割边:

```c++
int find(int x){
    if (f[x] != x)
    f[x] = find(f[x]);
    return f[x];
}
int Union(int x,int y){
    x = find(x);
    y = find(y);
    if (x != y)
    {
        f[y] = x;
        return 1;
    }
    else
    return 0;

}
void tarjan(int i,int pre){
    int j,k;
    low[i] = dfn[i] = ++index;
    for (k = 0; k < g[i].size(); ++k){
        j = g[i][k];
        if (!dfn[j]){
            tarjan(j,i);
            low[i] = min(low[i],low[j]);
            father[j] = i;//记录每个节点的父亲，方便后面的环中的查找
            if (low[j] > dfn[i])//记录桥数
             cut++;
            else
            Union(i,j);//把不是桥的缩为一点
        }
        else if (j != pre)//这里要注意不能是i的父亲，反之low[i] = low[father[i]]了;
        {
            low[i] = min(low[i],dfn[j]);
        }
    }
}
void lca(int u,int v){
    //在环中找桥的过程
    while (u != v){
        while (dfn[u] >= dfn[v] && u != v){
            if (Union(u,father[u]))
            cut--;
            u = father[u];
        }
        while (dfn[v] >= dfn[u] && u != v){
            if (Union(v,father[v]))
            cut--;
            v = father[v];
        }
    }
}
```



### Tarjan求双连通分量：

#### **tarjan缩点重建图+spfa求最长路**

题意：给定一个n*m的矩阵，你从左上角出发，规定只能往当前点的右边或者下边走，其中还有一些特殊点*具有特殊的力量可以把你传到特定的一个点（你可以选择传送也可以选择不传送），问从左上角出发到不能走下去，最多能获得的矿石量（每个方格对应着一个数字表示矿石数量）。点#直接跳过

 

思路：首先build1根据题意描述，见图，将二位矩阵转化为一维的点建图，每个点可以向右向下建立有向边，点*还可以向传送点建边。建完后tarjan缩点，然后在根据缩点后的点建图，添加超级源点s，权值为i-j sum[j],　　求最长路即可的结果;

 

中间数组开成了44贡献了几次wa，转化为1维后是40*40了。。。

```c++
int dir[2][2] = {{0,1},{1,0}};
const int inf = 99999999;
 
struct node
{
    int v,w;
    int next;
}g1[N*N],g2[N*N];
 
int head1[N],head2[N],ct1,ct2;
int low[N],dfn[N],stack[N],val[N];
int bcnt,top,index,num[maxn][maxn],kpos[N];
int belong[N],sum[N],dis[N];
bool inq[N],ins[N];
int n,m,ct,knum,s;
char str[maxn][maxn];
 
 
void add1(int u,int v)
{
    g1[ct1].v = v;
    g1[ct1].next = head1[u];
    head1[u] = ct1++;
}
void add2(int u,int v,int w)
{
    g2[ct2].v = v;
    g2[ct2].w  =w;
    g2[ct2].next = head2[u];
    head2[u] = ct2++;
}
void tarjan(int i)
{
    int k,j;
    low[i] = dfn[i] = ++index;
    ins[i] = true;
    stack[++top] = i;
    for (k = head1[i]; k != -1; k = g1[k].next)
    {
        int j = g1[k].v;
        if (!dfn[j])
        {
            tarjan(j);
            low[i] = min(low[i],low[j]);
        }
        else if (ins[j])
        {
            low[i] = min(low[i],dfn[j]);
        }
    }
    if (dfn[i] == low[i])
    {
        bcnt++;
        do
        {
            j = stack[top--];
            ins[j] = false;
            belong[j] = bcnt;
        }while (j != i);
    }
}
void build1()
{
    int i,j,k,x,y;
    memset(num,0,sizeof(num));
    memset(kpos,0,sizeof(kpos));
    memset(val,0,sizeof(val));
    ct = knum = 0;
    scanf("%d%d",&n,&m);
    for (i = 0; i < n; ++i)
    {
        scanf("%s",str[i]);
        for (j = 0; j < m; ++j)
        {
            if (str[i][j] == '#') continue;
            num[i][j] = ++ct;
            if (str[i][j] >= '0' && str[i][j] <= '9')
            val[num[i][j]] = str[i][j] - '0';
            else
            {
                kpos[knum++] = num[i][j];//记录每个*点，应为后边依次输入其传输的坐标
                val[num[i][j]] = 0;
            }
        }
    }
    memset(head1,-1,sizeof(head1));
    ct1 = 0;
    for (i = 0; i < n; ++i)
    {
        for (j = 0; j < m; ++j)
        {
            if (str[i][j] == '#') continue;
            for (k = 0; k < 2; ++k)
            {
                int tx = i + dir[k][0];
                int ty = j + dir[k][1];
                if (tx >= 0 && tx < n && ty >= 0 && ty < m)
                add1(num[i][j],num[tx][ty]);
            }
        }
    }
     //根据*点传输的坐标添加边
    for (i = 0; i < knum; ++i)
    {
        scanf("%d%d",&x,&y);
        add1(kpos[i],num[x][y]);
    }
 
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(ins,false,sizeof(ins));
    memset(belong,0,sizeof(belong));
    top = index = bcnt = 0;
    for (i = 1; i <= ct; ++i)
    {
        if (!dfn[i]) tarjan(i);//tarjan缩点
    }
    //缩点后计算权值
    memset(sum,0,sizeof(sum));
    for (i = 1; i <= ct; ++i)
    sum[belong[i]] += val[i];
}
void build2()
{
    int i,k;
    s = 0;
    memset(head2,-1,sizeof(head2));//加入超级源点
    ct2 = 0;
    add2(s,belong[1],sum[belong[1]]);
    for (i = 1; i <= ct; ++i)
    {
        for (k = head1[i]; k != -1; k = g1[k].next)
        {
            int j = g1[k].v;
            if (belong[i] != belong[j])
            {
                add2(belong[i],belong[j],sum[belong[j]]);
            }
        }
    }
}
void spfa(int s)
{
    int i;
    queue<int>q;
    for (i = 0; i < N; ++i)
    {
        dis[i] = -inf;
        inq[i] = false;
    }
    q.push(s); dis[s] = 0;
    inq[s] = true;
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        inq[u] = false;
        for (i = head2[u]; i != -1; i = g2[i].next)
        {
            int v = g2[i].v;
            if (dis[v] < dis[u] + g2[i].w)
            {
                dis[v] = dis[u] + g2[i].w;
                if (!inq[v])
                {
                    inq[v] = true;
                    q.push(v);
                }
            }
        }
    }
}
void solve()
{
    spfa(s);//求最长路
    int ans = 0;
    for (int i = 0; i <= bcnt; ++i)
    ans = max(ans,dis[i]);
    printf("%d\n",ans);
}
int main()
{
    int t;
    scanf("%d",&t);
    while (t--)
    {
        build1();//根据题意建图
        build2();//缩点后建图
        solve();//求解
    }
    return 0;
}
```



### 网络流系列:

#### 最大流：

##### Ek算法：

######　邻接矩阵实现　O(V*E^2)

```c++
int bfs(int s,int e){
    int i;
    queue<int>q;
    CL(vt,false); CL(pre,-1);//初始化
    for (i = 0; i <= n + 1; ++i) f[i] = inf;//注意这里的范围
    q.push(s);
    vt[s] = true;
    while (!q.empty()){
        int u = q.front(); q.pop();
        for (i = 0; i <= n + 1; ++i){
            //如果回到父亲节点，或者该点已经被访问过，或者这条路不满足有流量
            if (i == u || vt[i] || pre[i] != -1 || mp[u][i] <= 0) continue;
            vt[i] = true;
            f[i] = min(f[u],mp[u][i]);//选出该路径上的最小流量
            pre[i] = u;//记录i的父亲为u
            q.push(i);
            if (i == e) break;
        }
    }
    if (f[e] == inf) return -1;
    else return f[e];
}
int EK(int s,int e){
    int i;
    int ans = 0;
    while (1){
        int d = bfs(s,e);//寻找可行流
        if (d == -1) break;
        //更新流量
        for (i = e; i != s; i = pre[i]){
            int u = pre[i];
            mp[u][i] -= d;
            mp[i][u] += d;
        }
        ans += d;
    }
    return ans;
}
```

###### 邻接表实现：

```c++

struct node{
    int v,w;
    int next;
}g[M*4 + 10];
 
int head[N],ct;
 
void init(){
    ct = 0;
    CL(head,-1);
}
void add(int u,int v,int w){
    g[ct].v = v;
    g[ct].w = w;
    g[ct].next = head[u];
    head[u] = ct++;
 
    g[ct].v = u;
    g[ct].w = 0;
    g[ct].next = head[v];
    head[v] = ct++;
}
int bfs(int s,int e){
    int i;
 
    for (i = 0; i <= n; ++i) f[i] = inf;
    CL(vt,false); CL(pre,-1); CL(path,-1);
    queue<int>q;
    q.push(s); vt[s] = true;
 
    while (!q.empty()){
 
        int u = q.front(); q.pop();
        for (i = head[u]; i != -1; i = g[i].next){
            int v = g[i].v;
            if (vt[v] ||  g[i].w <= 0 || pre[g[i].v] != -1) continue;
            pre[v] = u; path[v] = i; vt[v] = true;//多了一个path记录可行流这条路上的路的编号
            f[v] = min(f[u],g[i].w);
            if (v == e) break;
            q.push(v);
        }
    }
    if (f[e] == inf) return -1;
    else return f[e];
}
int EK(int s,int e){
    int i,ans = 0;
    while (1){
        int d = bfs(s,e);
        if (d == -1) break;
        int tp;
        for (i = e; i != s; i = pre[i]){
            tp = path[i];//去路径编号
            g[tp].w -= d;
            g[tp^1].w += d;
        }
        ans += d;
    }
    return ans;
}
```

还有一种写法就是记录逆向边，这里不用记录们因为当前变与逆变abs（差值）= 1，取抑或即可。

---



##### Ｄinic算法:

###### 邻接表实现: O（V^2*E）

```c++
struct node{
    int v,w;
    int next;
}g[M*4 + 10];
int head[N],ct;
 
void init(){
    ct = 0;
    CL(head,-1);
}
void add(int u,int v,int w){
    g[ct].v = v;
    g[ct].w = w;
    g[ct].next = head[u];
    head[u] = ct++;
 
    g[ct].v = u;
    g[ct].w = 0;
    g[ct].next = head[v];
    head[v] = ct++;
}
//分层
bool layer(int s,int e){
    int i;
    CL(level,-1);
    level[s] = 0;
    int l,r;
    l = r = 0;
    q[r] = s;
    while (l <= r){
        int u = q[l++];
        for (i = head[u]; i != -1; i = g[i].next){
            int v = g[i].v;
            if (level[v] == -1 && g[i].w > 0){
                level[v] = level[u] + 1;
                q[++r] = v;
                if (v == e) return true;
            }
        }
    }
    return false;
}
int find(int s,int e){
    int i;
    int ans = 0;
    int top = 1;
 
    while (top){
        int u = (top == 1 ? s : g[q[top - 1]].v);//如果没有变肯定是起点，否则就是上一个边终点
 
        if (u == e){
            int MIN = inf,pos;
            //找出最小流量
            for (i = 1; i < top; ++i){
                int tp = q[i];//注意这里取边的编号
                if (g[tp].w < MIN){
                    MIN = g[tp].w;
                    pos = i;
                }
            }
            //更新容量
            for (i = 1; i < top; ++i){
                int tp = q[i];//注意这里取边的编号
                g[tp].w -= MIN;
                g[tp^1].w += MIN;
            }
            ans += MIN;
            top = pos;
        }
        else{//找可行流
            for (i = head[u]; i != -1; i = g[i].next){
                int v = g[i].v;
                if (g[i].w > 0 && level[v] == level[u] + 1){
                    q[top++] = i;
                    break;
                 }
            }
            if (i == -1){//如果u没有可走的子节点
                top--;
                level[u] = -1;
            }
        }
    }
    return ans;
}
int Dinic(int s,int e){
    int ans = 0;
    while (layer(s,e)) ans += find(s,e);//分层成功找可行流
    return ans;
}
```



###### 邻接矩阵：

```c++
bool layer(int s,int e)
{
    queue<int>q;
    memset(level,-1,sizeof(level));
    q.push(s);
    level[s] = 1;
    int i,p;
    while (!q.empty())
    {
        p = q.front();
        q.pop();
        for (i = 0; i <= e; ++i)
        {
            if (g[p][i] > 0 && level[i] == -1)//满足还没有分层，且p与i有流量
            {
                level[i] = level[p] + 1;
                if (i == e) { return true;}
                else q.push(i);
            }
        }
    }
    return false;
}
int dinic(int s,int e)
{
    deque<int>q;//利用双端队列
    int i,p,vs,ve,min,pos,sum;
    sum = 0;
    while (layer(s,e))
    {
        memset(vt,false,sizeof(vt));
        q.push_back(s);//从后端插入
        vt[s] = true;
        while (!q.empty())
        {
            p = q.back();//从后端取值
            if (p == e)//如果得到了终点
            {
                min = inf;
                for (i = 1; i < q.size(); ++i)
                {
                    vs = q[i - 1]; ve = q[i];
                    if (g[vs][ve] > 0 && g[vs][ve] < min)
                    {
                        min = g[vs][ve];
                        pos = vs;
                    }
                }
                sum += min;
                for (i = 1; i < q.size(); ++i)
                {
                    vs = q[i - 1]; ve = q[i];
                    if (g[vs][ve] > 0)
                    {
                        g[vs][ve] -= min;
                        g[ve][vs] += min;
                    }
                }
                while (!q.empty() && q.back() != pos)//返回最小流量的边的定点，重新找增广路
                {
                    vt[q.back()] = false;
                    q.pop_back();
                }
            }
            else//继续找下一层
            {
                for (i = 0; i <= e; ++i)
                {
                    if (g[p][i] > 0 && !vt[i] && level[i] == level[p] + 1)
                    {
                        vt[i] = true;
                        q.push_back(i);
                        break;
                    }
                }
                if (i > e) q.pop_back();
            }
        }
    }
    return sum;
}
```



##### 最小费用最大流：

```c++
struct node{
    int x,y;
}p[maxn],h[maxn];
int c[maxn][maxn],f[maxn][maxn],w[maxn][maxn];
int pre[maxn],dis[maxn];
int n,m,pn,hn,s,t;
char str[maxn][maxn];
bool inq[maxn];
int ans;

int Abs(int x){
    return x > 0 ? x : -x;
}
void spfa(){
    int v;
    queue<int>q;
    for (int i = 0; i < maxn; ++i){
        dis[i] = inf; pre[i] = -1;
        inq[i] = false;
    }
    q.push(s); inq[s] = true; dis[s] = 0;
    while (!q.empty()){
        int u = q.front(); q.pop();
        inq[u] = false;
        for (v = 0; v <= t; ++v){
            if (c[u][v]&& dis[v] > dis[u] + w[u][v]){
                dis[v] = dis[u] + w[u][v];
                pre[v] = u;
                if (!inq[v]){
                    q.push(v);
                    inq[v] = true;
                }
            }
        }
    }
}
void mcmf(){
    while (1){
        spfa();
        if (pre[t] == -1) break;
        int x = t,minf = inf;
        while (pre[x] != -1){
            minf = min(minf,c[pre[x]][x]);
            x = pre[x];
        }
        x = t;
        while (pre[x] != -1){
            c[pre[x]][x] -= minf;
            c[x][pre[x]] += minf;
            ans += minf*w[pre[x]][x];
            x = pre[x];
        }
    }
}
```



##### 最大费用最大流：

```c++
struct node
{
    int u,v;
    int c,w;
    int next;
}g[maxn*100];
int head[maxn],cnt,pre[maxn];
int dis[maxn],map[maxn][maxn];
bool inq[maxn];
int n,m,k,s,t,ans;
 
//为静态表初始化
void init(){
    memset(head,-1,sizeof(head));
    cnt = 0;
}
//加边，记住反向边去权值取反
void add(int u,int v,int c,int w){
    g[cnt].u = u; g[cnt].v = v; g[cnt].c = c; g[cnt].w = w;
    g[cnt].next = head[u]; head[u] = cnt++;
 
    g[cnt].u = v; g[cnt].v = u; g[cnt].c = 0; g[cnt].w = -w;
    g[cnt].next = head[v]; head[v] = cnt++;
}
void spfa(){
    int i;
    queue<int>q;
    for (i = 0; i <= t; ++i){
        dis[i] = -inf;
        inq[i] = false;
        pre[i] = -1;
    }
    q.push(s); inq[s] = true;
    dis[s] = 0;
    while (!q.empty()){
        int u = q.front(); q.pop();
        inq[u] = false;
        for (i = head[u]; i != -1; i = g[i].next){
            int v = g[i].v;
            if (g[i].c && dis[v] < dis[u] + g[i].w){
                dis[v] = dis[u] + g[i].w;
                pre[v] = i;//注意这里记录的是这一条边了
                if (!inq[v]){
                    inq[v] = true;
                    q.push(v);
                }
            }
        }
    }
}
void MCMF(){
   while (1){
       spfa();
       if (pre[t] == -1) break;
       int x = t,minf = inf;
       while (x != s){
           minf = min(minf,g[pre[x]].c);
           x = g[pre[x]].u;
       }
       x = t;
       while (x != s){
           g[pre[x]].c -= minf;
           g[pre[x]^1].c += minf;
           x = g[pre[x]].u;
       }
       ans += minf*dis[t];
   }
}
```



#### LCA最近公共优先：

##### rmq在线解决：

```c++
struct node{
    int v;
    int next;
}g[N];
int head[N],ct;

int E[2*N],R[N],D[2*N];
int dp[2*N][20],f[N],pow2[21];
bool vt[N];
int n,cnt;

void init(){
    for (int i = 0; i <= n; ++i){
        f[i] = -1;
        head[i] = -1;
    }
    ct = 0; cnt = 0;
    CL(vt,false);
}
void add(int u,int v){
    g[ct].v = v;
    g[ct].next = head[u];
    head[u] = ct++;
}
//E,R,D对应的值
void dfs(int u,int dep){
    vt[u] = true;
    E[cnt] = u;
    R[u] = cnt;
    D[cnt++] = dep;
    for (int i = head[u]; i != -1; i = g[i].next){
        int v = g[i].v;
        if (!vt[v]){
            dfs(v,dep + 1);
            E[cnt] = u;
            D[cnt++] = dep;
        }
    }
}
int MIN(int i,int j){
    if (D[i] < D[j]) return i;
    else return j;
}
void init_rmq(){

    int nn = 2*n - 1;
    int i,j;
    for (i = 0; i < nn; ++i)
        dp[i][0] = i;

    for (j = 1; pow2[j] <= nn; ++j){
        for (i = 0; (i + pow2[j] - 1) < nn; ++i)
        dp[i][j] = MIN(dp[i][j - 1],dp[i + pow2[j - 1]][j  - 1]);
    }
}
int rmq(int l,int r){
    int k = (int)(log(1.0*(r - l + 1))/log(2.0));
    return MIN(dp[l][k],dp[r - pow2[k] + 1][k]);
}
scanf("%d%d",&x,&y);
if (R[x] <= R[y]) printf("%d\n",E[rmq(R[x],R[y])]);
else printf("%d\n",E[rmq(R[y],R[x])]);
```



##### 离线处理：

```c++
struct node{
    int v;
    int next;
}g[N];

int head[N],ct;
bool vt[N];
vector<int>ask[N];
int f[N],pa[N],pre[N];
int n;

int find(int x){
    if (x != f[x]) f[x] = find(f[x]);
    return f[x];
}
void Union(int x,int y){
    x = find(x);
    y = find(y);
    f[x] = y;
}
void add(int u,int v){
    g[ct].v = v;
    g[ct].next = head[u];
    head[u] = ct++;
}
void LCA(int u){
    int i;
    f[u] = u;//建立以当前节点为根的树
    for (i = head[u]; i != -1; i = g[i].next){
        int v = g[i].v;
        LCA(v);
        Union(u,v);//记住是u指向v
        pa[find(u)] = u;//记录该树的父节点
    }

    vt[u] = true;

    int sz = ask[u].size();
    for (i = 0; i < sz; ++i){
        if (vt[ask[u][i]]){//如果同时访问就可求出lca
            printf("%d\n",pa[find(ask[u][i])]);
        }
    }
}
```



#### 差分约束：

第一： 

感觉难点在于建图 

第二： 

①：对于差分不等式，a - b <= c ，建一条 b 到 a 的权值为 c 的边，求的是最短路，得到的是最大值 

②：对于不等式 a - b >= c ，建一条 b 到 a 的权值为 c 的边，求的是最长路，得到的是最小值 

③：存在负环的话是无解 

④：求不出最短路（dist[ ]没有得到更新）的话是任意解 

第三： 

一种建图方法： 

设x[i]是第i位置（或时刻）的值（跟所求值的属性一样），那么把x[i]看成数列，前n项和为s[n]，则x[i] = s[i] - s[i-1]； 

那么这样就可以最起码建立起类似这样的一个关系：0 <= s[i] - s[i-1] <= 1; 

其他关系就要去题目探索了

##### Spfa实现

```c++
bool spfa(int u){
    int i;
    for (i = mi; i <= ma; ++i) dis[i] = -inf;
    dis[u] = 0;
    queue<int>q;
    q.push(u); inq[u] = true;
    while (!q.empty())
    {
        int cur = q.front(); q.pop();
        if (++ind[cur] > n) return false;
        inq[cur] = false;
        for (i = pre[cur];  i != -1; i = e[i].next)
        {
            int v = e[i].v; int w = e[i].w;
            if (dis[v] < dis[cur] + w)
            {
                dis[v] = dis[cur] + w;
                if (!inq[v])
                {
                    q.push(v);
                    inq[v] = true;
                }
            }
        }
    }
    return true;
}
```



##### Bellman_ford实现：

```c++
void add(int u,int v,int w)
{
    e[cnt].u = u;
    e[cnt].v = v;
    e[cnt].w = w;
    cnt++;
}
bool bellman_ford()
{
    int i,j;
    for (i = 0; i <= n; ++i) dis[i] = inf;
    dis[0] = 0;
    bool flag;
    for (i = 0; i <= n; ++i)
    {
        flag = true;
        for (j = 0; j < m; ++j)
        {
            int u = e[j].u;
            int v = e[j].v;
            int w = e[j].w;
            if (dis[v] > dis[u] + w)
            {
                dis[v] = dis[u] + w;
                flag = false;
            }
        }
        if (flag) break;
    }
    return flag;
}
```



